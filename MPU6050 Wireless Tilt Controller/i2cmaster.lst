   1               		.file	"i2cmaster.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	i2c_init
  12               	i2c_init:
  13               	.LFB6:
  14               		.file 1 "i2cmaster.c"
   1:i2cmaster.c   **** /*************************************************************************
   2:i2cmaster.c   **** * Title:    I2C master library using hardware TWI interface
   3:i2cmaster.c   **** * Author:   Peter Fleury <pfleury@gmx.ch>  http://jump.to/fleury
   4:i2cmaster.c   **** * File:     $Id: twimaster.c,v 1.3 2005/07/02 11:14:21 Peter Exp $
   5:i2cmaster.c   **** * Software: AVR-GCC 3.4.3 / avr-libc 1.2.3
   6:i2cmaster.c   **** * Target:   any AVR device with hardware TWI 
   7:i2cmaster.c   **** * Usage:    API compatible with I2C Software Library i2cmaster.h
   8:i2cmaster.c   **** **************************************************************************/
   9:i2cmaster.c   **** #include <inttypes.h>
  10:i2cmaster.c   **** #include <compat/twi.h>
  11:i2cmaster.c   **** #include <util/delay.h>
  12:i2cmaster.c   **** #include "i2cmaster.h"
  13:i2cmaster.c   **** 
  14:i2cmaster.c   **** 
  15:i2cmaster.c   **** /* define CPU frequency in Mhz here if not defined in Makefile */
  16:i2cmaster.c   **** #ifndef F_CPU
  17:i2cmaster.c   **** //#define F_CPU 8000000UL
  18:i2cmaster.c   **** #endif
  19:i2cmaster.c   **** 
  20:i2cmaster.c   **** /* I2C clock in Hz */
  21:i2cmaster.c   **** #define SCL_CLOCK  10000L
  22:i2cmaster.c   **** 
  23:i2cmaster.c   **** 
  24:i2cmaster.c   **** /*************************************************************************
  25:i2cmaster.c   ****  Initialization of the I2C bus interface. Need to be called only once
  26:i2cmaster.c   **** *************************************************************************/
  27:i2cmaster.c   **** void i2c_init(void)
  28:i2cmaster.c   **** {
  15               		.loc 1 28 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  29:i2cmaster.c   ****   /* initialize TWI clock: 100 kHz clock, TWPS = 0 => prescaler = 1 */
  30:i2cmaster.c   ****   
  31:i2cmaster.c   ****   TWSR = 0;                         /* no prescaler */
  21               		.loc 1 31 0
  22 0000 1092 B900 		sts 185,__zero_reg__
  32:i2cmaster.c   ****   TWBR = (uint8_t)(((F_CPU/SCL_CLOCK)-16)/2);  /* must be > 10 for stable operation */
  23               		.loc 1 32 0
  24 0004 88E1      		ldi r24,lo8(24)
  25 0006 8093 B800 		sts 184,r24
  26 000a 0895      		ret
  27               		.cfi_endproc
  28               	.LFE6:
  30               	.global	i2c_sync
  32               	i2c_sync:
  33               	.LFB7:
  33:i2cmaster.c   **** 
  34:i2cmaster.c   **** }/* i2c_init */
  35:i2cmaster.c   **** 
  36:i2cmaster.c   **** uint8_t i2c_sync(void){
  34               		.loc 1 36 0
  35               		.cfi_startproc
  36               	/* prologue: function */
  37               	/* frame size = 0 */
  38               	/* stack size = 0 */
  39               	.L__stack_usage = 0
  40               	.LVL0:
  37:i2cmaster.c   **** 	uint16_t timeout = 100; 
  41               		.loc 1 37 0
  42 000c 24E6      		ldi r18,lo8(100)
  43 000e 30E0      		ldi r19,0
  44               	.LVL1:
  45               	.L3:
  38:i2cmaster.c   **** 	while(!(TWCR & (1<<TWINT)) && timeout) {
  46               		.loc 1 38 0 discriminator 1
  47 0010 8091 BC00 		lds r24,188
  48 0014 87FD      		sbrc r24,7
  49 0016 00C0      		rjmp .L4
  50               		.loc 1 38 0 is_stmt 0 discriminator 2
  51 0018 2115      		cp r18,__zero_reg__
  52 001a 3105      		cpc r19,__zero_reg__
  53 001c 01F0      		breq .L4
  54               	.LVL2:
  55               	.LBB6:
  56               	.LBB7:
  57               		.file 2 "/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h"
   1:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
   6:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
   9:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  12:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      distribution.
  16:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  17:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  21:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  33:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  35:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  38:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  41:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  42:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <math.h>
  45:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  46:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /** \file */
  47:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \code
  49:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \endcode
  53:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  54:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     used.
  58:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  59:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  68:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  77:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  81:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** */
  82:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  83:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  87:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  88:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  93:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  94:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  97:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  98:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
 103:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 104:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /**
 105:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 107:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 109:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 112:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 114:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 120:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 125:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 129:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 132:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 140:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  */
 141:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** void
 142:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** {
 144:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 152:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 155:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 158:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#else
 159:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//round up by default
 160:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#endif
 162:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 163:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 165:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #else
 166:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	{
 172:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		{
 176:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		}
 180:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		return;
 181:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	}
 182:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	else
 183:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
 186:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** }
 187:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 188:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /**
 189:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 191:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 193:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 196:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 198:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 202:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   
 207:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 211:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  
 214:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 222:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  */
 223:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** void
 224:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** {
 226:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	double __tmp ; 
 227:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 230:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 231:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 234:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 237:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 240:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#else
 241:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//round up by default
 242:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#endif
 244:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 245:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  58               		.loc 2 245 0 is_stmt 1
  59 001e 85E0      		ldi r24,lo8(5)
  60 0020 8A95      		1: dec r24
  61 0022 01F4      		brne 1b
  62 0024 0000      		nop
  63               	.LBE7:
  64               	.LBE6:
  39:i2cmaster.c   **** 		_delay_us(1); 
  40:i2cmaster.c   **** 		timeout--; 
  65               		.loc 1 40 0
  66 0026 2150      		subi r18,1
  67 0028 3109      		sbc r19,__zero_reg__
  68               	.LVL3:
  69 002a 00C0      		rjmp .L3
  70               	.LVL4:
  71               	.L4:
  41:i2cmaster.c   **** 	}
  42:i2cmaster.c   **** 	return timeout != 0; 
  72               		.loc 1 42 0
  73 002c 81E0      		ldi r24,lo8(1)
  74 002e 232B      		or r18,r19
  75 0030 01F4      		brne .L6
  76 0032 80E0      		ldi r24,0
  77               	.L6:
  43:i2cmaster.c   **** }
  78               		.loc 1 43 0
  79 0034 0895      		ret
  80               		.cfi_endproc
  81               	.LFE7:
  83               	.global	i2c_waitStop
  85               	i2c_waitStop:
  86               	.LFB8:
  44:i2cmaster.c   **** 
  45:i2cmaster.c   **** uint8_t i2c_waitStop(void){
  87               		.loc 1 45 0
  88               		.cfi_startproc
  89               	/* prologue: function */
  90               	/* frame size = 0 */
  91               	/* stack size = 0 */
  92               	.L__stack_usage = 0
  93               	.LVL5:
  46:i2cmaster.c   **** 	uint16_t timeout = 100; 
  94               		.loc 1 46 0
  95 0036 24E6      		ldi r18,lo8(100)
  96 0038 30E0      		ldi r19,0
  97               	.LVL6:
  98               	.L9:
  47:i2cmaster.c   **** 	while((TWCR & (1<<TWSTO)) && timeout) {
  99               		.loc 1 47 0 discriminator 1
 100 003a 8091 BC00 		lds r24,188
 101 003e 84FF      		sbrs r24,4
 102 0040 00C0      		rjmp .L10
 103               		.loc 1 47 0 is_stmt 0 discriminator 2
 104 0042 2115      		cp r18,__zero_reg__
 105 0044 3105      		cpc r19,__zero_reg__
 106 0046 01F0      		breq .L10
 107               	.LVL7:
 108               	.LBB8:
 109               	.LBB9:
 110               		.loc 2 245 0 is_stmt 1
 111 0048 85E0      		ldi r24,lo8(5)
 112 004a 8A95      		1: dec r24
 113 004c 01F4      		brne 1b
 114 004e 0000      		nop
 115               	.LBE9:
 116               	.LBE8:
  48:i2cmaster.c   **** 		_delay_us(1); 
  49:i2cmaster.c   **** 		timeout--; 
 117               		.loc 1 49 0
 118 0050 2150      		subi r18,1
 119 0052 3109      		sbc r19,__zero_reg__
 120               	.LVL8:
 121 0054 00C0      		rjmp .L9
 122               	.LVL9:
 123               	.L10:
  50:i2cmaster.c   **** 	}
  51:i2cmaster.c   **** 	return timeout != 0; 
 124               		.loc 1 51 0
 125 0056 81E0      		ldi r24,lo8(1)
 126 0058 232B      		or r18,r19
 127 005a 01F4      		brne .L12
 128 005c 80E0      		ldi r24,0
 129               	.L12:
  52:i2cmaster.c   **** }
 130               		.loc 1 52 0
 131 005e 0895      		ret
 132               		.cfi_endproc
 133               	.LFE8:
 135               	.global	i2c_start
 137               	i2c_start:
 138               	.LFB9:
  53:i2cmaster.c   **** /*************************************************************************	
  54:i2cmaster.c   ****   Issues a start condition and sends address and transfer direction.
  55:i2cmaster.c   ****   return 0 = device accessible, 1= failed to access device
  56:i2cmaster.c   **** *************************************************************************/
  57:i2cmaster.c   **** unsigned char i2c_start(unsigned char address)
  58:i2cmaster.c   **** {
 139               		.loc 1 58 0
 140               		.cfi_startproc
 141               	.LVL10:
 142 0060 CF93      		push r28
 143               	.LCFI0:
 144               		.cfi_def_cfa_offset 3
 145               		.cfi_offset 28, -2
 146               	/* prologue: function */
 147               	/* frame size = 0 */
 148               	/* stack size = 1 */
 149               	.L__stack_usage = 1
 150 0062 C82F      		mov r28,r24
  59:i2cmaster.c   ****     uint8_t   twst;
  60:i2cmaster.c   **** 
  61:i2cmaster.c   **** 	// send START condition
  62:i2cmaster.c   **** 	TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
 151               		.loc 1 62 0
 152 0064 84EA      		ldi r24,lo8(-92)
 153               	.LVL11:
 154 0066 8093 BC00 		sts 188,r24
  63:i2cmaster.c   **** 
  64:i2cmaster.c   **** 	// wait until transmission completed (this is stupid!!)
  65:i2cmaster.c   **** 	if(!i2c_sync()) return 0; 
 155               		.loc 1 65 0
 156 006a 0E94 0000 		call i2c_sync
 157               	.LVL12:
 158 006e 8823      		tst r24
 159 0070 01F0      		breq .L22
  66:i2cmaster.c   **** 
  67:i2cmaster.c   **** 	// check value of TWI Status Register. Mask prescaler bits.
  68:i2cmaster.c   **** 	twst = TW_STATUS & 0xF8;
 160               		.loc 1 68 0
 161 0072 9091 B900 		lds r25,185
 162 0076 987F      		andi r25,lo8(-8)
 163               	.LVL13:
  69:i2cmaster.c   **** 	if ( (twst != TW_START) && (twst != TW_REP_START)) return 1;
 164               		.loc 1 69 0
 165 0078 9830      		cpi r25,lo8(8)
 166 007a 01F0      		breq .L19
 167               		.loc 1 69 0 is_stmt 0 discriminator 1
 168 007c 9031      		cpi r25,lo8(16)
 169 007e 01F0      		breq .L19
 170               	.LVL14:
 171               	.L21:
 172               		.loc 1 69 0
 173 0080 81E0      		ldi r24,lo8(1)
 174 0082 00C0      		rjmp .L18
 175               	.LVL15:
 176               	.L19:
  70:i2cmaster.c   **** 
  71:i2cmaster.c   **** 	// send device address
  72:i2cmaster.c   **** 	TWDR = address;
 177               		.loc 1 72 0 is_stmt 1
 178 0084 C093 BB00 		sts 187,r28
  73:i2cmaster.c   **** 	TWCR = (1<<TWINT) | (1<<TWEN);
 179               		.loc 1 73 0
 180 0088 84E8      		ldi r24,lo8(-124)
 181 008a 8093 BC00 		sts 188,r24
  74:i2cmaster.c   **** 
  75:i2cmaster.c   **** 	// wail until transmission completed and ACK/NACK has been received
  76:i2cmaster.c   **** 	if(!i2c_sync()) return 0; 
 182               		.loc 1 76 0
 183 008e 0E94 0000 		call i2c_sync
 184               	.LVL16:
 185 0092 8823      		tst r24
 186 0094 01F0      		breq .L22
  77:i2cmaster.c   **** 	
  78:i2cmaster.c   **** 	// check value of TWI Status Register. Mask prescaler bits.
  79:i2cmaster.c   **** 	twst = TW_STATUS & 0xF8;
 187               		.loc 1 79 0
 188 0096 8091 B900 		lds r24,185
 189 009a 887F      		andi r24,lo8(-8)
 190               	.LVL17:
  80:i2cmaster.c   **** 	if ( (twst != TW_MT_SLA_ACK) && (twst != TW_MR_SLA_ACK) ) return 1;
 191               		.loc 1 80 0
 192 009c 8831      		cpi r24,lo8(24)
 193 009e 01F0      		breq .L22
 194               		.loc 1 80 0 is_stmt 0 discriminator 1
 195 00a0 8034      		cpi r24,lo8(64)
 196 00a2 01F4      		brne .L21
 197               	.LVL18:
 198               	.L22:
  81:i2cmaster.c   **** 
  82:i2cmaster.c   **** 	return 0;
 199               		.loc 1 82 0 is_stmt 1
 200 00a4 80E0      		ldi r24,0
 201               	.L18:
 202               	/* epilogue start */
  83:i2cmaster.c   **** 
  84:i2cmaster.c   **** }/* i2c_start */
 203               		.loc 1 84 0
 204 00a6 CF91      		pop r28
 205               	.LVL19:
 206 00a8 0895      		ret
 207               		.cfi_endproc
 208               	.LFE9:
 210               	.global	i2c_start_wait
 212               	i2c_start_wait:
 213               	.LFB10:
  85:i2cmaster.c   **** 
  86:i2cmaster.c   **** 
  87:i2cmaster.c   **** /*************************************************************************
  88:i2cmaster.c   ****  Issues a start condition and sends address and transfer direction.
  89:i2cmaster.c   ****  If device is busy, use ack polling to wait until device is ready
  90:i2cmaster.c   ****  
  91:i2cmaster.c   ****  Input:   address and transfer direction of I2C device
  92:i2cmaster.c   **** *************************************************************************/
  93:i2cmaster.c   **** uint8_t i2c_start_wait(unsigned char address)
  94:i2cmaster.c   **** {
 214               		.loc 1 94 0
 215               		.cfi_startproc
 216               	.LVL20:
 217 00aa EF92      		push r14
 218               	.LCFI1:
 219               		.cfi_def_cfa_offset 3
 220               		.cfi_offset 14, -2
 221 00ac FF92      		push r15
 222               	.LCFI2:
 223               		.cfi_def_cfa_offset 4
 224               		.cfi_offset 15, -3
 225 00ae 0F93      		push r16
 226               	.LCFI3:
 227               		.cfi_def_cfa_offset 5
 228               		.cfi_offset 16, -4
 229 00b0 1F93      		push r17
 230               	.LCFI4:
 231               		.cfi_def_cfa_offset 6
 232               		.cfi_offset 17, -5
 233 00b2 CF93      		push r28
 234               	.LCFI5:
 235               		.cfi_def_cfa_offset 7
 236               		.cfi_offset 28, -6
 237 00b4 DF93      		push r29
 238               	.LCFI6:
 239               		.cfi_def_cfa_offset 8
 240               		.cfi_offset 29, -7
 241               	/* prologue: function */
 242               	/* frame size = 0 */
 243               	/* stack size = 6 */
 244               	.L__stack_usage = 6
 245 00b6 182F      		mov r17,r24
 246               	.LVL21:
  95:i2cmaster.c   ****     uint8_t   twst;
  96:i2cmaster.c   **** 
  97:i2cmaster.c   ****     int retry = 2000; 
 247               		.loc 1 97 0
 248 00b8 C0ED      		ldi r28,lo8(-48)
 249 00ba D7E0      		ldi r29,lo8(7)
  98:i2cmaster.c   ****     while ( 1 )
  99:i2cmaster.c   ****     {
 100:i2cmaster.c   **** 	    // send START condition
 101:i2cmaster.c   **** 	    TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
 250               		.loc 1 101 0
 251 00bc 04EA      		ldi r16,lo8(-92)
 102:i2cmaster.c   ****     
 103:i2cmaster.c   ****     	// wait until transmission completed
 104:i2cmaster.c   ****     	if(!i2c_sync()) break; 
 105:i2cmaster.c   ****     
 106:i2cmaster.c   ****     	// check value of TWI Status Register. Mask prescaler bits.
 107:i2cmaster.c   ****     	twst = TW_STATUS & 0xF8;
 108:i2cmaster.c   ****     	if ( (twst != TW_START) && (twst != TW_REP_START)) continue;
 109:i2cmaster.c   ****     
 110:i2cmaster.c   ****     	// send device address
 111:i2cmaster.c   ****     	TWDR = address;
 112:i2cmaster.c   ****     	TWCR = (1<<TWINT) | (1<<TWEN);
 252               		.loc 1 112 0
 253 00be 84E8      		ldi r24,lo8(-124)
 254 00c0 F82E      		mov r15,r24
 255               	.LVL22:
 113:i2cmaster.c   ****     
 114:i2cmaster.c   ****     	// wail until transmission completed
 115:i2cmaster.c   ****     	if(!i2c_sync()) break; 
 116:i2cmaster.c   ****     
 117:i2cmaster.c   ****     	// check value of TWI Status Register. Mask prescaler bits.
 118:i2cmaster.c   ****     	twst = TW_STATUS & 0xF8;
 119:i2cmaster.c   ****     	if ( (twst == TW_MT_SLA_NACK )||(twst ==TW_MR_DATA_NACK) ) 
 120:i2cmaster.c   ****     	{    	    
 121:i2cmaster.c   ****     	    /* device busy, send stop condition to terminate write operation */
 122:i2cmaster.c   **** 	        TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
 256               		.loc 1 122 0
 257 00c2 94E9      		ldi r25,lo8(-108)
 258 00c4 E92E      		mov r14,r25
 259               	.LVL23:
 260               	.L33:
 101:i2cmaster.c   **** 	    TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
 261               		.loc 1 101 0
 262 00c6 0093 BC00 		sts 188,r16
 104:i2cmaster.c   ****     	if(!i2c_sync()) break; 
 263               		.loc 1 104 0
 264 00ca 0E94 0000 		call i2c_sync
 265               	.LVL24:
 266 00ce 8111      		cpse r24,__zero_reg__
 267 00d0 00C0      		rjmp .L34
 268               	.LVL25:
 269               	.L38:
 123:i2cmaster.c   **** 	        
 124:i2cmaster.c   **** 	        // wait until stop condition is executed and bus released
 125:i2cmaster.c   **** 	        if(!i2c_waitStop()) continue; 
 126:i2cmaster.c   **** 
 127:i2cmaster.c   **** 	        if(!(retry --)) break;  
 128:i2cmaster.c   ****     	    continue;
 129:i2cmaster.c   ****     	}
 130:i2cmaster.c   ****     	return 1; 
 131:i2cmaster.c   ****     	//if( twst != TW_MT_SLA_ACK) return 1;
 132:i2cmaster.c   ****     	break;
 133:i2cmaster.c   ****      }
 134:i2cmaster.c   **** 	return 0; 
 270               		.loc 1 134 0
 271 00d2 80E0      		ldi r24,0
 272 00d4 00C0      		rjmp .L35
 273               	.LVL26:
 274               	.L34:
 107:i2cmaster.c   ****     	twst = TW_STATUS & 0xF8;
 275               		.loc 1 107 0
 276 00d6 9091 B900 		lds r25,185
 277 00da 987F      		andi r25,lo8(-8)
 278               	.LVL27:
 108:i2cmaster.c   ****     	if ( (twst != TW_START) && (twst != TW_REP_START)) continue;
 279               		.loc 1 108 0
 280 00dc 9830      		cpi r25,lo8(8)
 281 00de 01F0      		breq .L36
 108:i2cmaster.c   ****     	if ( (twst != TW_START) && (twst != TW_REP_START)) continue;
 282               		.loc 1 108 0 is_stmt 0 discriminator 1
 283 00e0 9031      		cpi r25,lo8(16)
 284 00e2 01F4      		brne .L33
 285               	.L36:
 111:i2cmaster.c   ****     	TWDR = address;
 286               		.loc 1 111 0 is_stmt 1
 287 00e4 1093 BB00 		sts 187,r17
 112:i2cmaster.c   ****     	TWCR = (1<<TWINT) | (1<<TWEN);
 288               		.loc 1 112 0
 289 00e8 F092 BC00 		sts 188,r15
 115:i2cmaster.c   ****     	if(!i2c_sync()) break; 
 290               		.loc 1 115 0
 291 00ec 0E94 0000 		call i2c_sync
 292               	.LVL28:
 293 00f0 8823      		tst r24
 294 00f2 01F0      		breq .L38
 118:i2cmaster.c   ****     	twst = TW_STATUS & 0xF8;
 295               		.loc 1 118 0
 296 00f4 9091 B900 		lds r25,185
 297 00f8 987F      		andi r25,lo8(-8)
 298               	.LVL29:
 119:i2cmaster.c   ****     	if ( (twst == TW_MT_SLA_NACK )||(twst ==TW_MR_DATA_NACK) ) 
 299               		.loc 1 119 0
 300 00fa 9032      		cpi r25,lo8(32)
 301 00fc 01F0      		breq .L39
 119:i2cmaster.c   ****     	if ( (twst == TW_MT_SLA_NACK )||(twst ==TW_MR_DATA_NACK) ) 
 302               		.loc 1 119 0 is_stmt 0 discriminator 1
 303 00fe 9835      		cpi r25,lo8(88)
 304 0100 01F4      		brne .L40
 305               	.L39:
 122:i2cmaster.c   **** 	        TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
 306               		.loc 1 122 0 is_stmt 1
 307 0102 E092 BC00 		sts 188,r14
 125:i2cmaster.c   **** 	        if(!i2c_waitStop()) continue; 
 308               		.loc 1 125 0
 309 0106 0E94 0000 		call i2c_waitStop
 310               	.LVL30:
 311 010a 8823      		tst r24
 312 010c 01F0      		breq .L33
 313               	.LVL31:
 127:i2cmaster.c   **** 	        if(!(retry --)) break;  
 314               		.loc 1 127 0
 315 010e 2097      		sbiw r28,0
 316 0110 01F0      		breq .L38
 317 0112 2197      		sbiw r28,1
 318               	.LVL32:
 319 0114 00C0      		rjmp .L33
 320               	.LVL33:
 321               	.L40:
 130:i2cmaster.c   ****     	return 1; 
 322               		.loc 1 130 0
 323 0116 81E0      		ldi r24,lo8(1)
 324               	.LVL34:
 325               	.L35:
 326               	/* epilogue start */
 135:i2cmaster.c   **** }/* i2c_start_wait */
 327               		.loc 1 135 0
 328 0118 DF91      		pop r29
 329 011a CF91      		pop r28
 330 011c 1F91      		pop r17
 331               	.LVL35:
 332 011e 0F91      		pop r16
 333 0120 FF90      		pop r15
 334 0122 EF90      		pop r14
 335 0124 0895      		ret
 336               		.cfi_endproc
 337               	.LFE10:
 339               	.global	i2c_rep_start
 341               	i2c_rep_start:
 342               	.LFB11:
 136:i2cmaster.c   **** 
 137:i2cmaster.c   **** 
 138:i2cmaster.c   **** /*************************************************************************
 139:i2cmaster.c   ****  Issues a repeated start condition and sends address and transfer direction 
 140:i2cmaster.c   **** 
 141:i2cmaster.c   ****  Input:   address and transfer direction of I2C device
 142:i2cmaster.c   ****  
 143:i2cmaster.c   ****  Return:  0 device accessible
 144:i2cmaster.c   ****           1 failed to access device
 145:i2cmaster.c   **** *************************************************************************/
 146:i2cmaster.c   **** unsigned char i2c_rep_start(unsigned char address)
 147:i2cmaster.c   **** {
 343               		.loc 1 147 0
 344               		.cfi_startproc
 345               	.LVL36:
 346               	/* prologue: function */
 347               	/* frame size = 0 */
 348               	/* stack size = 0 */
 349               	.L__stack_usage = 0
 148:i2cmaster.c   ****     return i2c_start( address );
 350               		.loc 1 148 0
 351 0126 0C94 0000 		jmp i2c_start
 352               	.LVL37:
 353               		.cfi_endproc
 354               	.LFE11:
 356               	.global	i2c_stop
 358               	i2c_stop:
 359               	.LFB12:
 149:i2cmaster.c   **** 
 150:i2cmaster.c   **** }/* i2c_rep_start */
 151:i2cmaster.c   **** 
 152:i2cmaster.c   **** 
 153:i2cmaster.c   **** /*************************************************************************
 154:i2cmaster.c   ****  Terminates the data transfer and releases the I2C bus
 155:i2cmaster.c   **** *************************************************************************/
 156:i2cmaster.c   **** void i2c_stop(void)
 157:i2cmaster.c   **** {
 360               		.loc 1 157 0
 361               		.cfi_startproc
 362               	/* prologue: function */
 363               	/* frame size = 0 */
 364               	/* stack size = 0 */
 365               	.L__stack_usage = 0
 158:i2cmaster.c   ****     /* send stop condition */
 159:i2cmaster.c   **** 	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
 366               		.loc 1 159 0
 367 012a 84E9      		ldi r24,lo8(-108)
 368 012c 8093 BC00 		sts 188,r24
 160:i2cmaster.c   **** 	
 161:i2cmaster.c   **** 	// wait until stop condition is executed and bus released
 162:i2cmaster.c   **** 	i2c_waitStop(); 
 369               		.loc 1 162 0
 370 0130 0C94 0000 		jmp i2c_waitStop
 371               	.LVL38:
 372               		.cfi_endproc
 373               	.LFE12:
 375               	.global	i2c_write
 377               	i2c_write:
 378               	.LFB13:
 163:i2cmaster.c   **** 
 164:i2cmaster.c   **** }/* i2c_stop */
 165:i2cmaster.c   **** 
 166:i2cmaster.c   **** 
 167:i2cmaster.c   **** /*************************************************************************
 168:i2cmaster.c   ****   Send one byte to I2C device
 169:i2cmaster.c   ****   
 170:i2cmaster.c   ****   Input:    byte to be transfered
 171:i2cmaster.c   ****   Return:   0 write successful 
 172:i2cmaster.c   ****             1 write failed
 173:i2cmaster.c   **** *************************************************************************/
 174:i2cmaster.c   **** unsigned char i2c_write( unsigned char data )
 175:i2cmaster.c   **** {	
 379               		.loc 1 175 0
 380               		.cfi_startproc
 381               	.LVL39:
 382               	/* prologue: function */
 383               	/* frame size = 0 */
 384               	/* stack size = 0 */
 385               	.L__stack_usage = 0
 176:i2cmaster.c   ****     uint8_t   twst;
 177:i2cmaster.c   ****     
 178:i2cmaster.c   **** 	// send data to the previously addressed device
 179:i2cmaster.c   **** 	TWDR = data;
 386               		.loc 1 179 0
 387 0134 8093 BB00 		sts 187,r24
 180:i2cmaster.c   **** 	TWCR = (1<<TWINT) | (1<<TWEN);
 388               		.loc 1 180 0
 389 0138 84E8      		ldi r24,lo8(-124)
 390               	.LVL40:
 391 013a 8093 BC00 		sts 188,r24
 392               	.LVL41:
 181:i2cmaster.c   **** 
 182:i2cmaster.c   **** 	// wait until transmission completed
 183:i2cmaster.c   **** 	i2c_sync(); 
 393               		.loc 1 183 0
 394 013e 0E94 0000 		call i2c_sync
 395               	.LVL42:
 184:i2cmaster.c   **** 
 185:i2cmaster.c   **** 	// check value of TWI Status Register. Mask prescaler bits
 186:i2cmaster.c   **** 	twst = TW_STATUS & 0xF8;
 396               		.loc 1 186 0
 397 0142 9091 B900 		lds r25,185
 398               	.LVL43:
 399 0146 987F      		andi r25,lo8(-8)
 400               	.LVL44:
 187:i2cmaster.c   **** 	if( twst != TW_MT_DATA_ACK) return 1;
 401               		.loc 1 187 0
 402 0148 81E0      		ldi r24,lo8(1)
 403 014a 9832      		cpi r25,lo8(40)
 404 014c 01F4      		brne .L59
 405 014e 80E0      		ldi r24,0
 406               	.L59:
 188:i2cmaster.c   **** 	return 0;
 189:i2cmaster.c   **** 
 190:i2cmaster.c   **** }/* i2c_write */
 407               		.loc 1 190 0
 408 0150 0895      		ret
 409               		.cfi_endproc
 410               	.LFE13:
 412               	.global	i2c_readAck
 414               	i2c_readAck:
 415               	.LFB14:
 191:i2cmaster.c   **** 
 192:i2cmaster.c   **** 
 193:i2cmaster.c   **** /*************************************************************************
 194:i2cmaster.c   ****  Read one byte from the I2C device, request more data from device 
 195:i2cmaster.c   ****  
 196:i2cmaster.c   ****  Return:  byte read from I2C device
 197:i2cmaster.c   **** *************************************************************************/
 198:i2cmaster.c   **** unsigned char i2c_readAck(void)
 199:i2cmaster.c   **** {
 416               		.loc 1 199 0
 417               		.cfi_startproc
 418               	/* prologue: function */
 419               	/* frame size = 0 */
 420               	/* stack size = 0 */
 421               	.L__stack_usage = 0
 200:i2cmaster.c   **** 	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA);
 422               		.loc 1 200 0
 423 0152 84EC      		ldi r24,lo8(-60)
 424 0154 8093 BC00 		sts 188,r24
 201:i2cmaster.c   **** 	i2c_sync();    
 425               		.loc 1 201 0
 426 0158 0E94 0000 		call i2c_sync
 427               	.LVL45:
 202:i2cmaster.c   **** 	return TWDR;
 428               		.loc 1 202 0
 429 015c 8091 BB00 		lds r24,187
 203:i2cmaster.c   **** }/* i2c_readAck */
 430               		.loc 1 203 0
 431 0160 0895      		ret
 432               		.cfi_endproc
 433               	.LFE14:
 435               	.global	i2c_readNak
 437               	i2c_readNak:
 438               	.LFB15:
 204:i2cmaster.c   **** 
 205:i2cmaster.c   **** 
 206:i2cmaster.c   **** /*************************************************************************
 207:i2cmaster.c   ****  Read one byte from the I2C device, read is followed by a stop condition 
 208:i2cmaster.c   ****  
 209:i2cmaster.c   ****  Return:  byte read from I2C device
 210:i2cmaster.c   **** *************************************************************************/
 211:i2cmaster.c   **** unsigned char i2c_readNak(void)
 212:i2cmaster.c   **** {
 439               		.loc 1 212 0
 440               		.cfi_startproc
 441               	/* prologue: function */
 442               	/* frame size = 0 */
 443               	/* stack size = 0 */
 444               	.L__stack_usage = 0
 213:i2cmaster.c   **** 	TWCR = (1<<TWINT) | (1<<TWEN);
 445               		.loc 1 213 0
 446 0162 84E8      		ldi r24,lo8(-124)
 447 0164 8093 BC00 		sts 188,r24
 214:i2cmaster.c   **** 	i2c_sync(); 
 448               		.loc 1 214 0
 449 0168 0E94 0000 		call i2c_sync
 450               	.LVL46:
 215:i2cmaster.c   **** 	return TWDR;
 451               		.loc 1 215 0
 452 016c 8091 BB00 		lds r24,187
 216:i2cmaster.c   **** }/* i2c_readNak */
 453               		.loc 1 216 0
 454 0170 0895      		ret
 455               		.cfi_endproc
 456               	.LFE15:
 458               	.Letext0:
 459               		.file 3 "/usr/local/CrossPack-AVR-20131216/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:00000000 i2cmaster.c
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccGOZVOd.s:2      *ABS*:0000003e __SP_H__
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccGOZVOd.s:3      *ABS*:0000003d __SP_L__
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccGOZVOd.s:4      *ABS*:0000003f __SREG__
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccGOZVOd.s:5      *ABS*:00000000 __tmp_reg__
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccGOZVOd.s:6      *ABS*:00000001 __zero_reg__
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccGOZVOd.s:12     .text:00000000 i2c_init
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccGOZVOd.s:32     .text:0000000c i2c_sync
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccGOZVOd.s:85     .text:00000036 i2c_waitStop
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccGOZVOd.s:137    .text:00000060 i2c_start
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccGOZVOd.s:212    .text:000000aa i2c_start_wait
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccGOZVOd.s:341    .text:00000126 i2c_rep_start
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccGOZVOd.s:358    .text:0000012a i2c_stop
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccGOZVOd.s:377    .text:00000134 i2c_write
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccGOZVOd.s:414    .text:00000152 i2c_readAck
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccGOZVOd.s:437    .text:00000162 i2c_readNak

NO UNDEFINED SYMBOLS
