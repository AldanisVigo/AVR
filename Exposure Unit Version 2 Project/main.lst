   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	uart_putchar
  12               	uart_putchar:
  13               	.LFB8:
  14               		.file 1 "main.c"
   1:main.c        **** //Defines
   2:main.c        **** #ifndef BAUD
   3:main.c        **** #define BAUD 9600
   4:main.c        **** #endif
   5:main.c        **** #define F_CPU 16000000UL
   6:main.c        **** #define CHECK_BIT(var,pos) ((var) & (1<<(pos)))
   7:main.c        **** #include <avr/io.h>
   8:main.c        **** #include <util/delay.h>
   9:main.c        **** #include <stdio.h>
  10:main.c        **** #include <string.h>
  11:main.c        **** #include <util/setbaud.h>
  12:main.c        **** #include <stdbool.h>
  13:main.c        **** 
  14:main.c        **** //Prototypes
  15:main.c        **** int uart_putchar(char c, FILE *stream);
  16:main.c        **** int uart_getchar(FILE *stream);
  17:main.c        **** 
  18:main.c        **** //Globals
  19:main.c        **** FILE uart_tx = FDEV_SETUP_STREAM(uart_putchar, NULL, _FDEV_SETUP_WRITE);
  20:main.c        **** FILE uart_rx = FDEV_SETUP_STREAM(NULL,uart_getchar, _FDEV_SETUP_READ);
  21:main.c        **** 
  22:main.c        **** void init_UART(void) {
  23:main.c        ****     UBRR0H = UBRRH_VALUE;
  24:main.c        ****     UBRR0L = UBRRL_VALUE;
  25:main.c        **** 
  26:main.c        ****     UCSR0C = _BV(UCSZ01) | _BV(UCSZ00);
  27:main.c        ****     UCSR0B = _BV(RXEN0) | _BV(TXEN0);
  28:main.c        **** }
  29:main.c        **** 
  30:main.c        **** int uart_putchar(char c, FILE *stream) {
  15               		.loc 1 30 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22               	/* prologue: function */
  23               	/* frame size = 0 */
  24               	/* stack size = 1 */
  25               	.L__stack_usage = 1
  26 0002 C82F      		mov r28,r24
  31:main.c        ****     if (c == '\n') {
  27               		.loc 1 31 0
  28 0004 8A30      		cpi r24,lo8(10)
  29 0006 01F4      		brne .L4
  32:main.c        ****         uart_putchar('\r', stream);
  30               		.loc 1 32 0
  31 0008 8DE0      		ldi r24,lo8(13)
  32               	.LVL1:
  33 000a 0E94 0000 		call uart_putchar
  34               	.LVL2:
  35               	.L4:
  33:main.c        ****     }
  34:main.c        ****     loop_until_bit_is_set(UCSR0A, UDRE0);
  36               		.loc 1 34 0 discriminator 1
  37 000e 8091 C000 		lds r24,192
  38 0012 85FF      		sbrs r24,5
  39 0014 00C0      		rjmp .L4
  35:main.c        ****     UDR0 = c;
  40               		.loc 1 35 0
  41 0016 C093 C600 		sts 198,r28
  36:main.c        ****     return 0;
  37:main.c        **** }
  42               		.loc 1 37 0
  43 001a 80E0      		ldi r24,0
  44 001c 90E0      		ldi r25,0
  45               	/* epilogue start */
  46 001e CF91      		pop r28
  47               	.LVL3:
  48 0020 0895      		ret
  49               		.cfi_endproc
  50               	.LFE8:
  52               	.global	uart_getchar
  54               	uart_getchar:
  55               	.LFB9:
  38:main.c        **** 
  39:main.c        **** int uart_getchar(FILE *stream) {
  56               		.loc 1 39 0
  57               		.cfi_startproc
  58               	/* prologue: function */
  59               	/* frame size = 0 */
  60               	/* stack size = 0 */
  61               	.L__stack_usage = 0
  62               	.LVL4:
  63               	.L8:
  40:main.c        ****     loop_until_bit_is_set(UCSR0A, RXC0);
  64               		.loc 1 40 0 discriminator 1
  65 0022 8091 C000 		lds r24,192
  66 0026 87FF      		sbrs r24,7
  67 0028 00C0      		rjmp .L8
  41:main.c        ****     return UDR0;
  68               		.loc 1 41 0
  69 002a 8091 C600 		lds r24,198
  42:main.c        **** }
  70               		.loc 1 42 0
  71 002e 90E0      		ldi r25,0
  72 0030 0895      		ret
  73               		.cfi_endproc
  74               	.LFE9:
  76               	.global	init_UART
  78               	init_UART:
  79               	.LFB7:
  22:main.c        **** void init_UART(void) {
  80               		.loc 1 22 0
  81               		.cfi_startproc
  82               	/* prologue: function */
  83               	/* frame size = 0 */
  84               	/* stack size = 0 */
  85               	.L__stack_usage = 0
  23:main.c        ****     UBRR0H = UBRRH_VALUE;
  86               		.loc 1 23 0
  87 0032 1092 C500 		sts 197,__zero_reg__
  24:main.c        ****     UBRR0L = UBRRL_VALUE;
  88               		.loc 1 24 0
  89 0036 87E6      		ldi r24,lo8(103)
  90 0038 8093 C400 		sts 196,r24
  26:main.c        ****     UCSR0C = _BV(UCSZ01) | _BV(UCSZ00);
  91               		.loc 1 26 0
  92 003c 86E0      		ldi r24,lo8(6)
  93 003e 8093 C200 		sts 194,r24
  27:main.c        ****     UCSR0B = _BV(RXEN0) | _BV(TXEN0);
  94               		.loc 1 27 0
  95 0042 88E1      		ldi r24,lo8(24)
  96 0044 8093 C100 		sts 193,r24
  97 0048 0895      		ret
  98               		.cfi_endproc
  99               	.LFE7:
 101               	.global	init_ADC
 103               	init_ADC:
 104               	.LFB10:
  43:main.c        **** 
  44:main.c        **** void init_ADC(){
 105               		.loc 1 44 0
 106               		.cfi_startproc
 107               	/* prologue: function */
 108               	/* frame size = 0 */
 109               	/* stack size = 0 */
 110               	.L__stack_usage = 0
  45:main.c        **** 	ADMUX=(1<<REFS0);                         // For Aref=AVcc;
 111               		.loc 1 45 0
 112 004a 80E4      		ldi r24,lo8(64)
 113 004c 8093 7C00 		sts 124,r24
  46:main.c        **** 	ADCSRA=(1<<ADEN)|(1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0); //Rrescalar div factor =128
 114               		.loc 1 46 0
 115 0050 87E8      		ldi r24,lo8(-121)
 116 0052 8093 7A00 		sts 122,r24
 117 0056 0895      		ret
 118               		.cfi_endproc
 119               	.LFE10:
 121               	.global	read_ADC
 123               	read_ADC:
 124               	.LFB11:
  47:main.c        **** }
  48:main.c        **** 
  49:main.c        **** uint16_t read_ADC(uint8_t ch,long * storein)
  50:main.c        **** {
 125               		.loc 1 50 0
 126               		.cfi_startproc
 127               	.LVL5:
 128               	/* prologue: function */
 129               	/* frame size = 0 */
 130               	/* stack size = 0 */
 131               	.L__stack_usage = 0
  51:main.c        **** 	//Select ADC Channel ch must be 0-7
  52:main.c        ****    	ch=ch&0b00000111;
  53:main.c        ****    	ADMUX|=ch;
 132               		.loc 1 53 0
 133 0058 9091 7C00 		lds r25,124
  52:main.c        ****    	ch=ch&0b00000111;
 134               		.loc 1 52 0
 135 005c 8770      		andi r24,lo8(7)
 136               	.LVL6:
 137               		.loc 1 53 0
 138 005e 892B      		or r24,r25
 139               	.LVL7:
 140 0060 8093 7C00 		sts 124,r24
  54:main.c        **** 	//Start Single conversion
  55:main.c        ****    	ADCSRA|=(1<<ADSC);
 141               		.loc 1 55 0
 142 0064 8091 7A00 		lds r24,122
 143 0068 8064      		ori r24,lo8(64)
 144 006a 8093 7A00 		sts 122,r24
 145               	.L13:
  56:main.c        ****    	//Wait for conversion to complete
  57:main.c        ****    	while(!(ADCSRA & (1<<ADIF)));
 146               		.loc 1 57 0 discriminator 1
 147 006e 8091 7A00 		lds r24,122
 148 0072 84FF      		sbrs r24,4
 149 0074 00C0      		rjmp .L13
  58:main.c        ****    	//Clear ADIF by writing one to it
  59:main.c        ****    	//Note you may be wondering why we have write one to clear it
  60:main.c        ****    	//This is standard way of clearing bits in io as said in datasheets.
  61:main.c        ****    	//The code writes '1' but it result in setting bit to '0' !!!
  62:main.c        **** 	ADCSRA|=(1<<ADIF);
 150               		.loc 1 62 0
 151 0076 8091 7A00 		lds r24,122
 152 007a 8061      		ori r24,lo8(16)
 153 007c 8093 7A00 		sts 122,r24
  63:main.c        **** 	*storein = ADC;
 154               		.loc 1 63 0
 155 0080 8091 7800 		lds r24,120
 156 0084 9091 7900 		lds r25,120+1
 157 0088 A0E0      		ldi r26,0
 158 008a B0E0      		ldi r27,0
 159 008c FB01      		movw r30,r22
 160 008e 8083      		st Z,r24
 161 0090 9183      		std Z+1,r25
 162 0092 A283      		std Z+2,r26
 163 0094 B383      		std Z+3,r27
  64:main.c        **** 	return(ADC);
 164               		.loc 1 64 0
 165 0096 8091 7800 		lds r24,120
 166 009a 9091 7900 		lds r25,120+1
  65:main.c        **** }
 167               		.loc 1 65 0
 168 009e 0895      		ret
 169               		.cfi_endproc
 170               	.LFE11:
 172               	.global	firstDisplay
 174               	firstDisplay:
 175               	.LFB12:
  66:main.c        **** 
  67:main.c        **** 
  68:main.c        **** void firstDisplay(uint8_t digit){
 176               		.loc 1 68 0
 177               		.cfi_startproc
 178               	.LVL8:
 179               	/* prologue: function */
 180               	/* frame size = 0 */
 181               	/* stack size = 0 */
 182               	.L__stack_usage = 0
  69:main.c        **** 	//digit = (digit << 4);
  70:main.c        **** 	//digit = ~digit;
  71:main.c        **** 	//clear the display first
  72:main.c        **** 	int cur_bit = 0;
  73:main.c        **** 	for(cur_bit = 0;cur_bit < 4;cur_bit++){
 183               		.loc 1 73 0
 184 00a0 20E0      		ldi r18,0
 185 00a2 30E0      		ldi r19,0
  74:main.c        **** 		if(CHECK_BIT(digit,cur_bit)){
 186               		.loc 1 74 0
 187 00a4 90E0      		ldi r25,0
 188               	.LVL9:
 189               	.L26:
 190 00a6 AC01      		movw r20,r24
 191 00a8 022E      		mov r0,r18
 192 00aa 00C0      		rjmp 2f
 193               		1:
 194 00ac 5595      		asr r21
 195 00ae 4795      		ror r20
 196               		2:
 197 00b0 0A94      		dec r0
 198 00b2 02F4      		brpl 1b
 199 00b4 40FF      		sbrs r20,0
 200 00b6 00C0      		rjmp .L15
  75:main.c        **** 			switch(cur_bit){
 201               		.loc 1 75 0
 202 00b8 2230      		cpi r18,2
 203 00ba 3105      		cpc r19,__zero_reg__
 204 00bc 01F0      		breq .L17
 205 00be 2330      		cpi r18,3
 206 00c0 3105      		cpc r19,__zero_reg__
 207 00c2 01F0      		breq .L18
 208 00c4 2130      		cpi r18,1
 209 00c6 3105      		cpc r19,__zero_reg__
 210 00c8 01F4      		brne .L27
  76:main.c        **** 				case 3:
  77:main.c        **** 					PORTD |= (1 << PD5);
  78:main.c        **** 					break;				
  79:main.c        **** 				case 2:
  80:main.c        **** 					PORTD |= (1 << PD6);
  81:main.c        **** 					break;
  82:main.c        **** 				case 1:
  83:main.c        **** 					PORTD |= (1 << PD7);
 211               		.loc 1 83 0
 212 00ca 5F9A      		sbi 0xb,7
  84:main.c        **** 					break;
 213               		.loc 1 84 0
 214 00cc 00C0      		rjmp .L20
 215               	.L18:
  77:main.c        **** 					PORTD |= (1 << PD5);
 216               		.loc 1 77 0
 217 00ce 5D9A      		sbi 0xb,5
  78:main.c        **** 					break;				
 218               		.loc 1 78 0
 219 00d0 00C0      		rjmp .L20
 220               	.L17:
  80:main.c        **** 					PORTD |= (1 << PD6);
 221               		.loc 1 80 0
 222 00d2 5E9A      		sbi 0xb,6
  81:main.c        **** 					break;
 223               		.loc 1 81 0
 224 00d4 00C0      		rjmp .L20
 225               	.L27:
  85:main.c        **** 				case 0:
  86:main.c        **** 					PORTB |= (1 << PB0);
 226               		.loc 1 86 0
 227 00d6 289A      		sbi 0x5,0
  87:main.c        **** 					break;
 228               		.loc 1 87 0
 229 00d8 00C0      		rjmp .L20
 230               	.L15:
  88:main.c        **** 				default:
  89:main.c        **** 					break;
  90:main.c        **** 			}
  91:main.c        **** 		}
  92:main.c        **** 		else{
  93:main.c        **** 			switch(cur_bit){
 231               		.loc 1 93 0
 232 00da 2230      		cpi r18,2
 233 00dc 3105      		cpc r19,__zero_reg__
 234 00de 01F0      		breq .L22
 235 00e0 2330      		cpi r18,3
 236 00e2 3105      		cpc r19,__zero_reg__
 237 00e4 01F0      		breq .L23
 238 00e6 2130      		cpi r18,1
 239 00e8 3105      		cpc r19,__zero_reg__
 240 00ea 01F4      		brne .L28
  94:main.c        **** 				case 3:
  95:main.c        **** 					PORTD &= ~(1 << PD5);
  96:main.c        **** 					break;
  97:main.c        **** 				case 2:
  98:main.c        **** 					PORTD &= ~(1 << PD6);
  99:main.c        **** 					break;
 100:main.c        **** 				case 1:
 101:main.c        **** 					PORTD &= ~(1 << PD7);
 241               		.loc 1 101 0
 242 00ec 5F98      		cbi 0xb,7
 102:main.c        **** 					break;
 243               		.loc 1 102 0
 244 00ee 00C0      		rjmp .L20
 245               	.L23:
  95:main.c        **** 					PORTD &= ~(1 << PD5);
 246               		.loc 1 95 0
 247 00f0 5D98      		cbi 0xb,5
  96:main.c        **** 					break;
 248               		.loc 1 96 0
 249 00f2 00C0      		rjmp .L20
 250               	.L22:
  98:main.c        **** 					PORTD &= ~(1 << PD6);
 251               		.loc 1 98 0
 252 00f4 5E98      		cbi 0xb,6
  99:main.c        **** 					break;
 253               		.loc 1 99 0
 254 00f6 00C0      		rjmp .L20
 255               	.L28:
 103:main.c        **** 				case 0:
 104:main.c        **** 					PORTB &= ~(1 << PB0);
 256               		.loc 1 104 0
 257 00f8 2898      		cbi 0x5,0
 258               	.L20:
  73:main.c        **** 	for(cur_bit = 0;cur_bit < 4;cur_bit++){
 259               		.loc 1 73 0
 260 00fa 2F5F      		subi r18,-1
 261 00fc 3F4F      		sbci r19,-1
 262               	.LVL10:
 263 00fe 2430      		cpi r18,4
 264 0100 3105      		cpc r19,__zero_reg__
 265 0102 01F4      		brne .L26
 266               	/* epilogue start */
 105:main.c        **** 					break;
 106:main.c        **** 				default:
 107:main.c        **** 					break;
 108:main.c        **** 			}
 109:main.c        **** 		}
 110:main.c        **** 	}
 111:main.c        **** }
 267               		.loc 1 111 0
 268 0104 0895      		ret
 269               		.cfi_endproc
 270               	.LFE12:
 272               	.global	secondDisplay
 274               	secondDisplay:
 275               	.LFB13:
 112:main.c        **** void secondDisplay(uint8_t digit){
 276               		.loc 1 112 0
 277               		.cfi_startproc
 278               	.LVL11:
 279               	/* prologue: function */
 280               	/* frame size = 0 */
 281               	/* stack size = 0 */
 282               	.L__stack_usage = 0
 113:main.c        ****         //digit = (digit << 4);
 114:main.c        ****         //digit = ~digit;
 115:main.c        ****         //clear the display first
 116:main.c        ****         int cur_bit = 0;
 117:main.c        ****         for(cur_bit = 0;cur_bit < 4;cur_bit++){
 283               		.loc 1 117 0
 284 0106 20E0      		ldi r18,0
 285 0108 30E0      		ldi r19,0
 118:main.c        ****                 if(CHECK_BIT(digit,cur_bit)){
 286               		.loc 1 118 0
 287 010a 90E0      		ldi r25,0
 288               	.LVL12:
 289               	.L41:
 290 010c AC01      		movw r20,r24
 291 010e 022E      		mov r0,r18
 292 0110 00C0      		rjmp 2f
 293               		1:
 294 0112 5595      		asr r21
 295 0114 4795      		ror r20
 296               		2:
 297 0116 0A94      		dec r0
 298 0118 02F4      		brpl 1b
 299 011a 40FF      		sbrs r20,0
 300 011c 00C0      		rjmp .L30
 119:main.c        ****                         switch(cur_bit){
 301               		.loc 1 119 0
 302 011e 2230      		cpi r18,2
 303 0120 3105      		cpc r19,__zero_reg__
 304 0122 01F0      		breq .L32
 305 0124 2330      		cpi r18,3
 306 0126 3105      		cpc r19,__zero_reg__
 307 0128 01F0      		breq .L33
 308 012a 2130      		cpi r18,1
 309 012c 3105      		cpc r19,__zero_reg__
 310 012e 01F4      		brne .L42
 120:main.c        ****                                 case 3:
 121:main.c        ****                                         PORTC |= (1 << PC1);
 122:main.c        ****                                         break;
 123:main.c        ****                                 case 2:
 124:main.c        ****                                         PORTC |= (1 << PC2);
 125:main.c        ****                                         break;
 126:main.c        ****                                 case 1:
 127:main.c        ****                                         PORTC |= (1 << PC3);
 311               		.loc 1 127 0
 312 0130 439A      		sbi 0x8,3
 128:main.c        ****                                         break;
 313               		.loc 1 128 0
 314 0132 00C0      		rjmp .L35
 315               	.L33:
 121:main.c        ****                                         PORTC |= (1 << PC1);
 316               		.loc 1 121 0
 317 0134 419A      		sbi 0x8,1
 122:main.c        ****                                         break;
 318               		.loc 1 122 0
 319 0136 00C0      		rjmp .L35
 320               	.L32:
 124:main.c        ****                                         PORTC |= (1 << PC2);
 321               		.loc 1 124 0
 322 0138 429A      		sbi 0x8,2
 125:main.c        ****                                         break;
 323               		.loc 1 125 0
 324 013a 00C0      		rjmp .L35
 325               	.L42:
 129:main.c        ****                                 case 0:
 130:main.c        ****                                         PORTC |= (1 << PC4);
 326               		.loc 1 130 0
 327 013c 449A      		sbi 0x8,4
 131:main.c        ****                                         break;
 328               		.loc 1 131 0
 329 013e 00C0      		rjmp .L35
 330               	.L30:
 132:main.c        ****                                 default:
 133:main.c        ****                                         break;
 134:main.c        ****                         }
 135:main.c        ****                 }
 136:main.c        ****                 else{
 137:main.c        ****                         switch(cur_bit){
 331               		.loc 1 137 0
 332 0140 2230      		cpi r18,2
 333 0142 3105      		cpc r19,__zero_reg__
 334 0144 01F0      		breq .L37
 335 0146 2330      		cpi r18,3
 336 0148 3105      		cpc r19,__zero_reg__
 337 014a 01F0      		breq .L38
 338 014c 2130      		cpi r18,1
 339 014e 3105      		cpc r19,__zero_reg__
 340 0150 01F4      		brne .L43
 138:main.c        ****                                 case 3:
 139:main.c        ****                                         PORTC &= ~(1 << PC1);
 140:main.c        ****                                         break;
 141:main.c        ****                                 case 2:
 142:main.c        ****                                         PORTC &= ~(1 << PC2);
 143:main.c        ****                                         break;
 144:main.c        ****                                 case 1:
 145:main.c        ****                                         PORTC &= ~(1 << PC3);
 341               		.loc 1 145 0
 342 0152 4398      		cbi 0x8,3
 146:main.c        ****                                         break;
 343               		.loc 1 146 0
 344 0154 00C0      		rjmp .L35
 345               	.L38:
 139:main.c        ****                                         PORTC &= ~(1 << PC1);
 346               		.loc 1 139 0
 347 0156 4198      		cbi 0x8,1
 140:main.c        ****                                         break;
 348               		.loc 1 140 0
 349 0158 00C0      		rjmp .L35
 350               	.L37:
 142:main.c        ****                                         PORTC &= ~(1 << PC2);
 351               		.loc 1 142 0
 352 015a 4298      		cbi 0x8,2
 143:main.c        ****                                         break;
 353               		.loc 1 143 0
 354 015c 00C0      		rjmp .L35
 355               	.L43:
 147:main.c        ****                                 case 0:
 148:main.c        ****                                         PORTC &= ~(1 << PC4);
 356               		.loc 1 148 0
 357 015e 4498      		cbi 0x8,4
 358               	.L35:
 117:main.c        ****         for(cur_bit = 0;cur_bit < 4;cur_bit++){
 359               		.loc 1 117 0
 360 0160 2F5F      		subi r18,-1
 361 0162 3F4F      		sbci r19,-1
 362               	.LVL13:
 363 0164 2430      		cpi r18,4
 364 0166 3105      		cpc r19,__zero_reg__
 365 0168 01F4      		brne .L41
 366               	/* epilogue start */
 149:main.c        ****                                         break;
 150:main.c        ****                                 default:
 151:main.c        ****                                         break;
 152:main.c        ****                         }
 153:main.c        ****                 }
 154:main.c        ****         }
 155:main.c        **** }
 367               		.loc 1 155 0
 368 016a 0895      		ret
 369               		.cfi_endproc
 370               	.LFE13:
 372               	.global	display_Selection
 374               	display_Selection:
 375               	.LFB14:
 156:main.c        **** 
 157:main.c        **** void display_Selection(uint8_t selection){
 376               		.loc 1 157 0
 377               		.cfi_startproc
 378               	.LVL14:
 379 016c 1F93      		push r17
 380               	.LCFI1:
 381               		.cfi_def_cfa_offset 3
 382               		.cfi_offset 17, -2
 383 016e CF93      		push r28
 384               	.LCFI2:
 385               		.cfi_def_cfa_offset 4
 386               		.cfi_offset 28, -3
 387 0170 DF93      		push r29
 388               	.LCFI3:
 389               		.cfi_def_cfa_offset 5
 390               		.cfi_offset 29, -4
 391 0172 1F92      		push __zero_reg__
 392               	.LCFI4:
 393               		.cfi_def_cfa_offset 6
 394 0174 CDB7      		in r28,__SP_L__
 395 0176 DEB7      		in r29,__SP_H__
 396               	.LCFI5:
 397               		.cfi_def_cfa_register 28
 398               	/* prologue: function */
 399               	/* frame size = 1 */
 400               	/* stack size = 4 */
 401               	.L__stack_usage = 4
 402 0178 182F      		mov r17,r24
 158:main.c        **** 	if(selection < 10){
 403               		.loc 1 158 0
 404 017a 8A30      		cpi r24,lo8(10)
 405 017c 00F4      		brsh .L45
 159:main.c        **** 		firstDisplay(0);
 406               		.loc 1 159 0
 407 017e 80E0      		ldi r24,0
 408               	.LVL15:
 409 0180 0E94 0000 		call firstDisplay
 410               	.LVL16:
 160:main.c        **** 		secondDisplay(selection);
 411               		.loc 1 160 0
 412 0184 812F      		mov r24,r17
 413 0186 00C0      		rjmp .L46
 414               	.L45:
 415               	.LVL17:
 416               	.LBB22:
 161:main.c        **** 	}
 162:main.c        **** 	else{
 163:main.c        **** 		uint8_t first_digit = selection / 10;
 417               		.loc 1 163 0
 418 0188 6AE0      		ldi r22,lo8(10)
 419 018a 0E94 0000 		call __udivmodqi4
 420               	.LVL18:
 164:main.c        **** 		uint8_t second_digit = selection % 10;
 165:main.c        **** 		firstDisplay(first_digit);
 421               		.loc 1 165 0
 422 018e 9983      		std Y+1,r25
 423 0190 0E94 0000 		call firstDisplay
 424               	.LVL19:
 166:main.c        **** 		secondDisplay(second_digit);
 425               		.loc 1 166 0
 426 0194 9981      		ldd r25,Y+1
 427 0196 892F      		mov r24,r25
 428               	.LVL20:
 429               	.L46:
 430               	/* epilogue start */
 431               	.LBE22:
 167:main.c        **** 	}
 168:main.c        **** }
 432               		.loc 1 168 0
 433 0198 0F90      		pop __tmp_reg__
 434 019a DF91      		pop r29
 435 019c CF91      		pop r28
 436 019e 1F91      		pop r17
 437               	.LVL21:
 438               	.LBB23:
 166:main.c        **** 		secondDisplay(second_digit);
 439               		.loc 1 166 0
 440 01a0 0C94 0000 		jmp secondDisplay
 441               	.LVL22:
 442               	.LBE23:
 443               		.cfi_endproc
 444               	.LFE14:
 446               	.global	mapRange
 448               	mapRange:
 449               	.LFB15:
 169:main.c        **** 
 170:main.c        **** long mapRange(long a1,long a2,long b1,long b2,long s)
 171:main.c        **** {
 450               		.loc 1 171 0
 451               		.cfi_startproc
 452               	.LVL23:
 453 01a4 4F92      		push r4
 454               	.LCFI6:
 455               		.cfi_def_cfa_offset 3
 456               		.cfi_offset 4, -2
 457 01a6 5F92      		push r5
 458               	.LCFI7:
 459               		.cfi_def_cfa_offset 4
 460               		.cfi_offset 5, -3
 461 01a8 6F92      		push r6
 462               	.LCFI8:
 463               		.cfi_def_cfa_offset 5
 464               		.cfi_offset 6, -4
 465 01aa 7F92      		push r7
 466               	.LCFI9:
 467               		.cfi_def_cfa_offset 6
 468               		.cfi_offset 7, -5
 469 01ac AF92      		push r10
 470               	.LCFI10:
 471               		.cfi_def_cfa_offset 7
 472               		.cfi_offset 10, -6
 473 01ae BF92      		push r11
 474               	.LCFI11:
 475               		.cfi_def_cfa_offset 8
 476               		.cfi_offset 11, -7
 477 01b0 CF92      		push r12
 478               	.LCFI12:
 479               		.cfi_def_cfa_offset 9
 480               		.cfi_offset 12, -8
 481 01b2 DF92      		push r13
 482               	.LCFI13:
 483               		.cfi_def_cfa_offset 10
 484               		.cfi_offset 13, -9
 485 01b4 EF92      		push r14
 486               	.LCFI14:
 487               		.cfi_def_cfa_offset 11
 488               		.cfi_offset 14, -10
 489 01b6 FF92      		push r15
 490               	.LCFI15:
 491               		.cfi_def_cfa_offset 12
 492               		.cfi_offset 15, -11
 493 01b8 0F93      		push r16
 494               	.LCFI16:
 495               		.cfi_def_cfa_offset 13
 496               		.cfi_offset 16, -12
 497 01ba 1F93      		push r17
 498               	.LCFI17:
 499               		.cfi_def_cfa_offset 14
 500               		.cfi_offset 17, -13
 501 01bc CF93      		push r28
 502               	.LCFI18:
 503               		.cfi_def_cfa_offset 15
 504               		.cfi_offset 28, -14
 505 01be DF93      		push r29
 506               	.LCFI19:
 507               		.cfi_def_cfa_offset 16
 508               		.cfi_offset 29, -15
 509 01c0 00D0      		rcall .
 510 01c2 00D0      		rcall .
 511               	.LCFI20:
 512               		.cfi_def_cfa_offset 20
 513 01c4 CDB7      		in r28,__SP_L__
 514 01c6 DEB7      		in r29,__SP_H__
 515               	.LCFI21:
 516               		.cfi_def_cfa_register 28
 517               	/* prologue: function */
 518               	/* frame size = 4 */
 519               	/* stack size = 18 */
 520               	.L__stack_usage = 18
 521 01c8 6983      		std Y+1,r22
 522 01ca 7A83      		std Y+2,r23
 523 01cc 8B83      		std Y+3,r24
 524 01ce 9C83      		std Y+4,r25
 525 01d0 2901      		movw r4,r18
 526 01d2 3A01      		movw r6,r20
 527 01d4 C601      		movw r24,r12
 528 01d6 B501      		movw r22,r10
 529               	.LVL24:
 530 01d8 2D89      		ldd r18,Y+21
 531 01da 3E89      		ldd r19,Y+22
 532 01dc 4F89      		ldd r20,Y+23
 533 01de 588D      		ldd r21,Y+24
 534               	.LVL25:
 172:main.c        **** 	return b1 + (s-a1)*(b2-b1)/(a2-a1);
 535               		.loc 1 172 0
 536 01e0 A980      		ldd r10,Y+1
 537 01e2 BA80      		ldd r11,Y+2
 538 01e4 CB80      		ldd r12,Y+3
 539 01e6 DC80      		ldd r13,Y+4
 540               	.LVL26:
 541 01e8 2A19      		sub r18,r10
 542 01ea 3B09      		sbc r19,r11
 543 01ec 4C09      		sbc r20,r12
 544 01ee 5D09      		sbc r21,r13
 545 01f0 6E19      		sub r22,r14
 546 01f2 7F09      		sbc r23,r15
 547 01f4 800B      		sbc r24,r16
 548 01f6 910B      		sbc r25,r17
 549               	.LVL27:
 550 01f8 0E94 0000 		call __mulsi3
 551 01fc 4A18      		sub r4,r10
 552 01fe 5B08      		sbc r5,r11
 553 0200 6C08      		sbc r6,r12
 554 0202 7D08      		sbc r7,r13
 555               	.LVL28:
 556 0204 A301      		movw r20,r6
 557 0206 9201      		movw r18,r4
 558 0208 0E94 0000 		call __divmodsi4
 559 020c 2E0D      		add r18,r14
 560 020e 3F1D      		adc r19,r15
 561 0210 401F      		adc r20,r16
 562 0212 511F      		adc r21,r17
 173:main.c        **** }
 563               		.loc 1 173 0
 564 0214 CA01      		movw r24,r20
 565 0216 B901      		movw r22,r18
 566               	/* epilogue start */
 567 0218 0F90      		pop __tmp_reg__
 568 021a 0F90      		pop __tmp_reg__
 569 021c 0F90      		pop __tmp_reg__
 570 021e 0F90      		pop __tmp_reg__
 571 0220 DF91      		pop r29
 572 0222 CF91      		pop r28
 573 0224 1F91      		pop r17
 574 0226 0F91      		pop r16
 575 0228 FF90      		pop r15
 576 022a EF90      		pop r14
 577               	.LVL29:
 578 022c DF90      		pop r13
 579 022e CF90      		pop r12
 580 0230 BF90      		pop r11
 581 0232 AF90      		pop r10
 582 0234 7F90      		pop r7
 583 0236 6F90      		pop r6
 584 0238 5F90      		pop r5
 585 023a 4F90      		pop r4
 586 023c 0895      		ret
 587               		.cfi_endproc
 588               	.LFE15:
 590               	.global	displayBlink
 592               	displayBlink:
 593               	.LFB16:
 174:main.c        **** 
 175:main.c        **** 
 176:main.c        **** void displayBlink(uint8_t reps){
 594               		.loc 1 176 0
 595               		.cfi_startproc
 596               	.LVL30:
 597 023e 0F93      		push r16
 598               	.LCFI22:
 599               		.cfi_def_cfa_offset 3
 600               		.cfi_offset 16, -2
 601 0240 1F93      		push r17
 602               	.LCFI23:
 603               		.cfi_def_cfa_offset 4
 604               		.cfi_offset 17, -3
 605 0242 CF93      		push r28
 606               	.LCFI24:
 607               		.cfi_def_cfa_offset 5
 608               		.cfi_offset 28, -4
 609 0244 DF93      		push r29
 610               	.LCFI25:
 611               		.cfi_def_cfa_offset 6
 612               		.cfi_offset 29, -5
 613               	/* prologue: function */
 614               	/* frame size = 0 */
 615               	/* stack size = 4 */
 616               	.L__stack_usage = 4
 617               	.LVL31:
 177:main.c        **** 	int rep = 0;
 178:main.c        **** 	for(rep = 0; rep < reps; rep++){
 618               		.loc 1 178 0
 619 0246 C0E0      		ldi r28,0
 620 0248 D0E0      		ldi r29,0
 621 024a 082F      		mov r16,r24
 622 024c 10E0      		ldi r17,0
 623               	.LVL32:
 624               	.L49:
 625               		.loc 1 178 0 is_stmt 0 discriminator 1
 626 024e C017      		cp r28,r16
 627 0250 D107      		cpc r29,r17
 628 0252 04F4      		brge .L51
 179:main.c        **** 		firstDisplay(0b1111);
 629               		.loc 1 179 0 is_stmt 1 discriminator 2
 630 0254 8FE0      		ldi r24,lo8(15)
 631 0256 0E94 0000 		call firstDisplay
 632               	.LVL33:
 180:main.c        **** 		secondDisplay(0b1111);
 633               		.loc 1 180 0 discriminator 2
 634 025a 8FE0      		ldi r24,lo8(15)
 635 025c 0E94 0000 		call secondDisplay
 636               	.LVL34:
 637               	.LBB24:
 638               	.LBB25:
 639               		.file 2 "/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h"
   1:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
   6:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
   9:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  12:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      distribution.
  16:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  17:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  21:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  33:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  35:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  38:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  41:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  42:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <math.h>
  45:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  46:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /** \file */
  47:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \code
  49:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \endcode
  53:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  54:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     used.
  58:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  59:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  68:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  77:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  81:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** */
  82:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  83:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  87:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  88:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  93:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  94:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  97:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  98:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
 103:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 104:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /**
 105:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 107:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 109:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 112:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 114:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 120:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 125:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 129:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 132:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 140:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  */
 141:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** void
 142:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** {
 144:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 152:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 155:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 158:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#else
 159:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//round up by default
 160:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#endif
 162:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 163:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 640               		.loc 2 163 0 discriminator 2
 641 0260 2FEF      		ldi r18,lo8(1599999)
 642 0262 89E6      		ldi r24,hi8(1599999)
 643 0264 98E1      		ldi r25,hlo8(1599999)
 644 0266 2150      		1: subi r18,1
 645 0268 8040      		sbci r24,0
 646 026a 9040      		sbci r25,0
 647 026c 01F4      		brne 1b
 648 026e 00C0      		rjmp .
 649 0270 0000      		nop
 650               	.LBE25:
 651               	.LBE24:
 181:main.c        **** 		_delay_ms(500);
 182:main.c        **** 		firstDisplay(8);
 652               		.loc 1 182 0 discriminator 2
 653 0272 88E0      		ldi r24,lo8(8)
 654 0274 0E94 0000 		call firstDisplay
 655               	.LVL35:
 183:main.c        **** 		secondDisplay(8);
 656               		.loc 1 183 0 discriminator 2
 657 0278 88E0      		ldi r24,lo8(8)
 658 027a 0E94 0000 		call secondDisplay
 659               	.LVL36:
 660               	.LBB26:
 661               	.LBB27:
 662               		.loc 2 163 0 discriminator 2
 663 027e 2FEF      		ldi r18,lo8(1599999)
 664 0280 89E6      		ldi r24,hi8(1599999)
 665 0282 98E1      		ldi r25,hlo8(1599999)
 666 0284 2150      		1: subi r18,1
 667 0286 8040      		sbci r24,0
 668 0288 9040      		sbci r25,0
 669 028a 01F4      		brne 1b
 670 028c 00C0      		rjmp .
 671 028e 0000      		nop
 672               	.LBE27:
 673               	.LBE26:
 178:main.c        **** 	for(rep = 0; rep < reps; rep++){
 674               		.loc 1 178 0 discriminator 2
 675 0290 2196      		adiw r28,1
 676               	.LVL37:
 677 0292 00C0      		rjmp .L49
 678               	.LVL38:
 679               	.L51:
 680               	/* epilogue start */
 184:main.c        **** 		_delay_ms(500);
 185:main.c        **** 	}
 186:main.c        **** }
 681               		.loc 1 186 0
 682 0294 DF91      		pop r29
 683 0296 CF91      		pop r28
 684               	.LVL39:
 685 0298 1F91      		pop r17
 686 029a 0F91      		pop r16
 687               	.LVL40:
 688 029c 0895      		ret
 689               		.cfi_endproc
 690               	.LFE16:
 692               	.global	delayMicro
 694               	delayMicro:
 695               	.LFB17:
 187:main.c        **** 
 188:main.c        **** #define NOTE_B0  31
 189:main.c        **** #define NOTE_C1  33
 190:main.c        **** #define NOTE_CS1 35
 191:main.c        **** #define NOTE_D1  37
 192:main.c        **** #define NOTE_DS1 39
 193:main.c        **** #define NOTE_E1  41
 194:main.c        **** #define NOTE_F1  44
 195:main.c        **** #define NOTE_FS1 46
 196:main.c        **** #define NOTE_G1  49
 197:main.c        **** #define NOTE_GS1 52
 198:main.c        **** #define NOTE_A1  55
 199:main.c        **** #define NOTE_AS1 58
 200:main.c        **** #define NOTE_B1  62
 201:main.c        **** #define NOTE_C2  65
 202:main.c        **** #define NOTE_CS2 69
 203:main.c        **** #define NOTE_D2  73
 204:main.c        **** #define NOTE_DS2 78
 205:main.c        **** #define NOTE_E2  82
 206:main.c        **** #define NOTE_F2  87
 207:main.c        **** #define NOTE_FS2 93
 208:main.c        **** #define NOTE_G2  98
 209:main.c        **** #define NOTE_GS2 104
 210:main.c        **** #define NOTE_A2  110
 211:main.c        **** #define NOTE_AS2 117
 212:main.c        **** #define NOTE_B2  123
 213:main.c        **** #define NOTE_C3  131
 214:main.c        **** #define NOTE_CS3 139
 215:main.c        **** #define NOTE_D3  147
 216:main.c        **** #define NOTE_DS3 156
 217:main.c        **** #define NOTE_E3  165
 218:main.c        **** #define NOTE_F3  175
 219:main.c        **** #define NOTE_FS3 185
 220:main.c        **** #define NOTE_G3  196
 221:main.c        **** #define NOTE_GS3 208
 222:main.c        **** #define NOTE_A3  220
 223:main.c        **** #define NOTE_AS3 233
 224:main.c        **** #define NOTE_B3  247
 225:main.c        **** #define NOTE_C4  262
 226:main.c        **** #define NOTE_CS4 277
 227:main.c        **** #define NOTE_D4  294
 228:main.c        **** #define NOTE_DS4 311
 229:main.c        **** #define NOTE_E4  330
 230:main.c        **** #define NOTE_F4  349
 231:main.c        **** #define NOTE_FS4 370
 232:main.c        **** #define NOTE_G4  392
 233:main.c        **** #define NOTE_GS4 415
 234:main.c        **** #define NOTE_A4  440
 235:main.c        **** #define NOTE_AS4 466
 236:main.c        **** #define NOTE_B4  494
 237:main.c        **** #define NOTE_C5  523
 238:main.c        **** #define NOTE_CS5 554
 239:main.c        **** #define NOTE_D5  587
 240:main.c        **** #define NOTE_DS5 622
 241:main.c        **** #define NOTE_E5  659
 242:main.c        **** #define NOTE_F5  698
 243:main.c        **** #define NOTE_FS5 740
 244:main.c        **** #define NOTE_G5  784
 245:main.c        **** #define NOTE_GS5 831
 246:main.c        **** #define NOTE_A5  880
 247:main.c        **** #define NOTE_AS5 932
 248:main.c        **** #define NOTE_B5  988
 249:main.c        **** #define NOTE_C6  1047
 250:main.c        **** #define NOTE_CS6 1109
 251:main.c        **** #define NOTE_D6  1175
 252:main.c        **** #define NOTE_DS6 1245
 253:main.c        **** #define NOTE_E6  1319
 254:main.c        **** #define NOTE_F6  1397
 255:main.c        **** #define NOTE_FS6 1480
 256:main.c        **** #define NOTE_G6  1568
 257:main.c        **** #define NOTE_GS6 1661
 258:main.c        **** #define NOTE_A6  1760
 259:main.c        **** #define NOTE_AS6 1865
 260:main.c        **** #define NOTE_B6  1976
 261:main.c        **** #define NOTE_C7  2093
 262:main.c        **** #define NOTE_CS7 2217
 263:main.c        **** #define NOTE_D7  2349
 264:main.c        **** #define NOTE_DS7 2489
 265:main.c        **** #define NOTE_E7  2637
 266:main.c        **** #define NOTE_F7  2794
 267:main.c        **** #define NOTE_FS7 2960
 268:main.c        **** #define NOTE_G7  3136
 269:main.c        **** #define NOTE_GS7 3322
 270:main.c        **** #define NOTE_A7  3520
 271:main.c        **** #define NOTE_AS7 3729
 272:main.c        **** #define NOTE_B7  3951
 273:main.c        **** #define NOTE_C8  4186
 274:main.c        **** #define NOTE_CS8 4435
 275:main.c        **** #define NOTE_D8  4699
 276:main.c        **** #define NOTE_DS8 4978
 277:main.c        **** int melody[] = {
 278:main.c        ****   NOTE_E7, NOTE_E7, 0, NOTE_E7,
 279:main.c        ****   0, NOTE_C7, NOTE_E7, 0,
 280:main.c        ****   NOTE_G7, 0, 0,  0,
 281:main.c        ****   NOTE_G6, 0, 0, 0,
 282:main.c        ****  
 283:main.c        ****   NOTE_C7, 0, 0, NOTE_G6,
 284:main.c        ****   0, 0, NOTE_E6, 0,
 285:main.c        ****   0, NOTE_A6, 0, NOTE_B6,
 286:main.c        ****   0, NOTE_AS6, NOTE_A6, 0,
 287:main.c        ****  
 288:main.c        ****   NOTE_G6, NOTE_E7, NOTE_G7,
 289:main.c        ****   NOTE_A7, 0, NOTE_F7, NOTE_G7,
 290:main.c        ****   0, NOTE_E7, 0, NOTE_C7,
 291:main.c        ****   NOTE_D7, NOTE_B6, 0, 0,
 292:main.c        ****  
 293:main.c        ****   NOTE_C7, 0, 0, NOTE_G6,
 294:main.c        ****   0, 0, NOTE_E6, 0,
 295:main.c        ****   0, NOTE_A6, 0, NOTE_B6,
 296:main.c        ****   0, NOTE_AS6, NOTE_A6, 0,
 297:main.c        ****  
 298:main.c        ****   NOTE_G6, NOTE_E7, NOTE_G7,
 299:main.c        ****   NOTE_A7, 0, NOTE_F7, NOTE_G7,
 300:main.c        ****   0, NOTE_E7, 0, NOTE_C7,
 301:main.c        ****   NOTE_D7, NOTE_B6, 0, 0
 302:main.c        **** };
 303:main.c        **** //Mario main them tempo
 304:main.c        **** int tempo[] = {
 305:main.c        ****   12, 12, 12, 12,
 306:main.c        ****   12, 12, 12, 12,
 307:main.c        ****   12, 12, 12, 12,
 308:main.c        ****   12, 12, 12, 12,
 309:main.c        ****  
 310:main.c        ****   12, 12, 12, 12,
 311:main.c        ****   12, 12, 12, 12,
 312:main.c        ****   12, 12, 12, 12,
 313:main.c        ****   12, 12, 12, 12,
 314:main.c        ****  
 315:main.c        ****   9, 9, 9,
 316:main.c        ****   12, 12, 12, 12,
 317:main.c        ****   12, 12, 12, 12,
 318:main.c        ****   12, 12, 12, 12,
 319:main.c        ****  
 320:main.c        ****   12, 12, 12, 12,
 321:main.c        ****   12, 12, 12, 12,
 322:main.c        ****   12, 12, 12, 12,
 323:main.c        ****   12, 12, 12, 12,
 324:main.c        ****  
 325:main.c        ****   9, 9, 9,
 326:main.c        ****   12, 12, 12, 12,
 327:main.c        ****   12, 12, 12, 12,
 328:main.c        ****   12, 12, 12, 12,
 329:main.c        **** };
 330:main.c        **** void delayMicro(uint8_t us){
 696               		.loc 1 330 0
 697               		.cfi_startproc
 698               	.LVL41:
 699               	/* prologue: function */
 700               	/* frame size = 0 */
 701               	/* stack size = 0 */
 702               	.L__stack_usage = 0
 703               	.L53:
 331:main.c        **** 	while(us-- != 0){
 704               		.loc 1 331 0 discriminator 1
 705 029e 8823      		tst r24
 706 02a0 01F0      		breq .L55
 707               	.LVL42:
 708               	.LBB28:
 709               	.LBB29:
 164:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 165:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #else
 166:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	{
 172:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		{
 176:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		}
 180:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		return;
 181:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	}
 182:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	else
 183:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
 186:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** }
 187:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 188:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /**
 189:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 191:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 193:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 196:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 198:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 202:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   
 207:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 211:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  
 214:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 222:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  */
 223:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** void
 224:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** {
 226:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	double __tmp ; 
 227:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 230:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 231:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 234:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 237:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 240:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#else
 241:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//round up by default
 242:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#endif
 244:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 245:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 710               		.loc 2 245 0
 711 02a2 95E0      		ldi r25,lo8(5)
 712 02a4 9A95      		1: dec r25
 713 02a6 01F4      		brne 1b
 714 02a8 0000      		nop
 715 02aa 8150      		subi r24,lo8(-(-1))
 716               	.LVL43:
 717 02ac 00C0      		rjmp .L53
 718               	.LVL44:
 719               	.L55:
 720               	/* epilogue start */
 721               	.LBE29:
 722               	.LBE28:
 332:main.c        **** 		_delay_us(1);
 333:main.c        **** 	}
 334:main.c        **** }
 723               		.loc 1 334 0
 724 02ae 0895      		ret
 725               		.cfi_endproc
 726               	.LFE17:
 728               	.global	buzz
 730               	buzz:
 731               	.LFB18:
 335:main.c        **** void buzz(long frequency, long length) {
 732               		.loc 1 335 0
 733               		.cfi_startproc
 734               	.LVL45:
 735 02b0 8F92      		push r8
 736               	.LCFI26:
 737               		.cfi_def_cfa_offset 3
 738               		.cfi_offset 8, -2
 739 02b2 9F92      		push r9
 740               	.LCFI27:
 741               		.cfi_def_cfa_offset 4
 742               		.cfi_offset 9, -3
 743 02b4 AF92      		push r10
 744               	.LCFI28:
 745               		.cfi_def_cfa_offset 5
 746               		.cfi_offset 10, -4
 747 02b6 BF92      		push r11
 748               	.LCFI29:
 749               		.cfi_def_cfa_offset 6
 750               		.cfi_offset 11, -5
 751 02b8 CF92      		push r12
 752               	.LCFI30:
 753               		.cfi_def_cfa_offset 7
 754               		.cfi_offset 12, -6
 755 02ba DF92      		push r13
 756               	.LCFI31:
 757               		.cfi_def_cfa_offset 8
 758               		.cfi_offset 13, -7
 759 02bc EF92      		push r14
 760               	.LCFI32:
 761               		.cfi_def_cfa_offset 9
 762               		.cfi_offset 14, -8
 763 02be FF92      		push r15
 764               	.LCFI33:
 765               		.cfi_def_cfa_offset 10
 766               		.cfi_offset 15, -9
 767 02c0 1F93      		push r17
 768               	.LCFI34:
 769               		.cfi_def_cfa_offset 11
 770               		.cfi_offset 17, -10
 771 02c2 CF93      		push r28
 772               	.LCFI35:
 773               		.cfi_def_cfa_offset 12
 774               		.cfi_offset 28, -11
 775 02c4 DF93      		push r29
 776               	.LCFI36:
 777               		.cfi_def_cfa_offset 13
 778               		.cfi_offset 29, -12
 779 02c6 00D0      		rcall .
 780 02c8 00D0      		rcall .
 781               	.LCFI37:
 782               		.cfi_def_cfa_offset 17
 783 02ca CDB7      		in r28,__SP_L__
 784 02cc DEB7      		in r29,__SP_H__
 785               	.LCFI38:
 786               		.cfi_def_cfa_register 28
 787               	/* prologue: function */
 788               	/* frame size = 4 */
 789               	/* stack size = 15 */
 790               	.L__stack_usage = 15
 791 02ce 6B01      		movw r12,r22
 792 02d0 7C01      		movw r14,r24
 793 02d2 4901      		movw r8,r18
 794 02d4 5A01      		movw r10,r20
 336:main.c        ****  	long delayValue = 1000000 / frequency / 2; // calculate the delay value between transitions
 795               		.loc 1 336 0
 796 02d6 60E2      		ldi r22,lo8(32)
 797 02d8 71EA      		ldi r23,lo8(-95)
 798 02da 87E0      		ldi r24,lo8(7)
 799 02dc 90E0      		ldi r25,0
 800               	.LVL46:
 801 02de A701      		movw r20,r14
 802 02e0 9601      		movw r18,r12
 803               	.LVL47:
 804 02e2 0E94 0000 		call __divmodsi4
 805 02e6 122F      		mov r17,r18
 806               	.LVL48:
 337:main.c        ****   	//// 1 second's worth of microseconds, divided by the frequency, then split in half since
 338:main.c        ****   	//// there are two phases to each cycle
 339:main.c        ****   	long numCycles = frequency * length / 1000; // calculate the number of cycles for proper timing
 807               		.loc 1 339 0
 808 02e8 A701      		movw r20,r14
 809 02ea 9601      		movw r18,r12
 810 02ec C501      		movw r24,r10
 811 02ee B401      		movw r22,r8
 812 02f0 0E94 0000 		call __mulsi3
 813 02f4 28EE      		ldi r18,lo8(-24)
 814 02f6 33E0      		ldi r19,lo8(3)
 815 02f8 40E0      		ldi r20,0
 816 02fa 50E0      		ldi r21,0
 817 02fc 0E94 0000 		call __divmodsi4
 818               	.LVL49:
 819               	.LBB30:
 340:main.c        ****   	//// multiply frequency, which is really cycles per second, by the number of seconds to
 341:main.c        ****   	//// get the total number of cycles to produce
 342:main.c        ****   	for (long i = 0; i < numCycles; i++) { // for the calculated length of time...
 820               		.loc 1 342 0
 821 0300 C12C      		mov r12,__zero_reg__
 822 0302 D12C      		mov r13,__zero_reg__
 823 0304 7601      		movw r14,r12
 824               	.LVL50:
 825               	.L57:
 826               		.loc 1 342 0 is_stmt 0 discriminator 1
 827 0306 C216      		cp r12,r18
 828 0308 D306      		cpc r13,r19
 829 030a E406      		cpc r14,r20
 830 030c F506      		cpc r15,r21
 831 030e 04F4      		brge .L59
 343:main.c        ****     		PORTD |= (1 << PD2); // write the buzzer pin high to push out the diaphram
 832               		.loc 1 343 0 is_stmt 1 discriminator 2
 833 0310 5A9A      		sbi 0xb,2
 344:main.c        ****     		delayMicro(delayValue); // wait for the calculated delay value
 834               		.loc 1 344 0 discriminator 2
 835 0312 812F      		mov r24,r17
 836 0314 2983      		std Y+1,r18
 837 0316 3A83      		std Y+2,r19
 838 0318 4B83      		std Y+3,r20
 839 031a 5C83      		std Y+4,r21
 840 031c 0E94 0000 		call delayMicro
 841               	.LVL51:
 345:main.c        ****     		PORTD &= ~(1 << PD2); // write the buzzer pin low to pull back the diaphram
 842               		.loc 1 345 0 discriminator 2
 843 0320 5A98      		cbi 0xb,2
 346:main.c        ****     		delayMicro(delayValue); // wait again or the calculated delay value
 844               		.loc 1 346 0 discriminator 2
 845 0322 812F      		mov r24,r17
 846 0324 0E94 0000 		call delayMicro
 847               	.LVL52:
 342:main.c        ****   	for (long i = 0; i < numCycles; i++) { // for the calculated length of time...
 848               		.loc 1 342 0 discriminator 2
 849 0328 8FEF      		ldi r24,-1
 850 032a C81A      		sub r12,r24
 851 032c D80A      		sbc r13,r24
 852 032e E80A      		sbc r14,r24
 853 0330 F80A      		sbc r15,r24
 854               	.LVL53:
 855 0332 5C81      		ldd r21,Y+4
 856 0334 4B81      		ldd r20,Y+3
 857 0336 3A81      		ldd r19,Y+2
 858 0338 2981      		ldd r18,Y+1
 859 033a 00C0      		rjmp .L57
 860               	.L59:
 861               	/* epilogue start */
 862               	.LBE30:
 347:main.c        ****   
 348:main.c        **** 	}
 349:main.c        **** }
 863               		.loc 1 349 0
 864 033c 0F90      		pop __tmp_reg__
 865 033e 0F90      		pop __tmp_reg__
 866 0340 0F90      		pop __tmp_reg__
 867 0342 0F90      		pop __tmp_reg__
 868 0344 DF91      		pop r29
 869 0346 CF91      		pop r28
 870 0348 1F91      		pop r17
 871 034a FF90      		pop r15
 872 034c EF90      		pop r14
 873 034e DF90      		pop r13
 874 0350 CF90      		pop r12
 875               	.LVL54:
 876 0352 BF90      		pop r11
 877 0354 AF90      		pop r10
 878 0356 9F90      		pop r9
 879 0358 8F90      		pop r8
 880               	.LVL55:
 881 035a 0895      		ret
 882               		.cfi_endproc
 883               	.LFE18:
 885               	.global	buzzerSound
 887               	buzzerSound:
 888               	.LFB19:
 350:main.c        **** void buzzerSound(uint8_t reps){
 889               		.loc 1 350 0
 890               		.cfi_startproc
 891               	.LVL56:
 892 035c 0F93      		push r16
 893               	.LCFI39:
 894               		.cfi_def_cfa_offset 3
 895               		.cfi_offset 16, -2
 896 035e 1F93      		push r17
 897               	.LCFI40:
 898               		.cfi_def_cfa_offset 4
 899               		.cfi_offset 17, -3
 900 0360 CF93      		push r28
 901               	.LCFI41:
 902               		.cfi_def_cfa_offset 5
 903               		.cfi_offset 28, -4
 904 0362 DF93      		push r29
 905               	.LCFI42:
 906               		.cfi_def_cfa_offset 6
 907               		.cfi_offset 29, -5
 908               	/* prologue: function */
 909               	/* frame size = 0 */
 910               	/* stack size = 4 */
 911               	.L__stack_usage = 4
 912               	.LVL57:
 351:main.c        **** 	int rep = 0;
 352:main.c        **** 	for(rep = 0;rep < reps;rep++){
 913               		.loc 1 352 0
 914 0364 C0E0      		ldi r28,0
 915 0366 D0E0      		ldi r29,0
 916 0368 082F      		mov r16,r24
 917 036a 10E0      		ldi r17,0
 918               	.LVL58:
 919               	.L61:
 920               		.loc 1 352 0 is_stmt 0 discriminator 1
 921 036c C017      		cp r28,r16
 922 036e D107      		cpc r29,r17
 923 0370 04F4      		brge .L63
 353:main.c        **** 		buzz(NOTE_C1,10000);
 924               		.loc 1 353 0 is_stmt 1 discriminator 2
 925 0372 20E1      		ldi r18,lo8(16)
 926 0374 37E2      		ldi r19,lo8(39)
 927 0376 40E0      		ldi r20,0
 928 0378 50E0      		ldi r21,0
 929 037a 61E2      		ldi r22,lo8(33)
 930 037c 70E0      		ldi r23,0
 931 037e 80E0      		ldi r24,0
 932 0380 90E0      		ldi r25,0
 933 0382 0E94 0000 		call buzz
 934               	.LVL59:
 352:main.c        **** 	for(rep = 0;rep < reps;rep++){
 935               		.loc 1 352 0 discriminator 2
 936 0386 2196      		adiw r28,1
 937               	.LVL60:
 938 0388 00C0      		rjmp .L61
 939               	.L63:
 940               	/* epilogue start */
 354:main.c        **** 	}
 355:main.c        **** }
 941               		.loc 1 355 0
 942 038a DF91      		pop r29
 943 038c CF91      		pop r28
 944               	.LVL61:
 945 038e 1F91      		pop r17
 946 0390 0F91      		pop r16
 947               	.LVL62:
 948 0392 0895      		ret
 949               		.cfi_endproc
 950               	.LFE19:
 952               	.global	__floatsisf
 953               	.global	__mulsf3
 954               	.global	__fixsfsi
 955               	.global	alarmSound
 957               	alarmSound:
 958               	.LFB20:
 356:main.c        **** void alarmSound(uint8_t reps){
 959               		.loc 1 356 0
 960               		.cfi_startproc
 961               	.LVL63:
 962 0394 4F92      		push r4
 963               	.LCFI43:
 964               		.cfi_def_cfa_offset 3
 965               		.cfi_offset 4, -2
 966 0396 5F92      		push r5
 967               	.LCFI44:
 968               		.cfi_def_cfa_offset 4
 969               		.cfi_offset 5, -3
 970 0398 6F92      		push r6
 971               	.LCFI45:
 972               		.cfi_def_cfa_offset 5
 973               		.cfi_offset 6, -4
 974 039a 7F92      		push r7
 975               	.LCFI46:
 976               		.cfi_def_cfa_offset 6
 977               		.cfi_offset 7, -5
 978 039c AF92      		push r10
 979               	.LCFI47:
 980               		.cfi_def_cfa_offset 7
 981               		.cfi_offset 10, -6
 982 039e BF92      		push r11
 983               	.LCFI48:
 984               		.cfi_def_cfa_offset 8
 985               		.cfi_offset 11, -7
 986 03a0 CF92      		push r12
 987               	.LCFI49:
 988               		.cfi_def_cfa_offset 9
 989               		.cfi_offset 12, -8
 990 03a2 DF92      		push r13
 991               	.LCFI50:
 992               		.cfi_def_cfa_offset 10
 993               		.cfi_offset 13, -9
 994 03a4 EF92      		push r14
 995               	.LCFI51:
 996               		.cfi_def_cfa_offset 11
 997               		.cfi_offset 14, -10
 998 03a6 FF92      		push r15
 999               	.LCFI52:
 1000               		.cfi_def_cfa_offset 12
 1001               		.cfi_offset 15, -11
 1002 03a8 0F93      		push r16
 1003               	.LCFI53:
 1004               		.cfi_def_cfa_offset 13
 1005               		.cfi_offset 16, -12
 1006 03aa 1F93      		push r17
 1007               	.LCFI54:
 1008               		.cfi_def_cfa_offset 14
 1009               		.cfi_offset 17, -13
 1010 03ac CF93      		push r28
 1011               	.LCFI55:
 1012               		.cfi_def_cfa_offset 15
 1013               		.cfi_offset 28, -14
 1014 03ae DF93      		push r29
 1015               	.LCFI56:
 1016               		.cfi_def_cfa_offset 16
 1017               		.cfi_offset 29, -15
 1018               	/* prologue: function */
 1019               	/* frame size = 0 */
 1020               	/* stack size = 14 */
 1021               	.L__stack_usage = 14
 1022               	.LVL64:
 357:main.c        **** 	int rep = 0;
 358:main.c        **** 	for(rep = 0;rep < reps;rep++){
 1023               		.loc 1 358 0
 1024 03b0 00E0      		ldi r16,0
 1025 03b2 10E0      		ldi r17,0
 1026 03b4 C82E      		mov r12,r24
 1027 03b6 D12C      		mov r13,__zero_reg__
 1028               	.LBB31:
 1029               	.LBB32:
 1030               	.LBB33:
 359:main.c        **** 		int size = sizeof(melody) / sizeof(int);
 360:main.c        ****     		for (int thisNote = 0; thisNote < size; thisNote++) {
 361:main.c        ****  			// to calculate the note duration, take one second
 362:main.c        ****       			// divided by the note type.
 363:main.c        ****       			//e.g. quarter note = 1000 / 4, eighth note = 1000/8, etc.
 364:main.c        ****      		 	int noteDuration = 1000 / tempo[thisNote];
 1031               		.loc 1 364 0
 1032 03b8 98EE      		ldi r25,lo8(-24)
 1033 03ba A92E      		mov r10,r25
 1034 03bc 93E0      		ldi r25,lo8(3)
 1035 03be B92E      		mov r11,r25
 1036               	.LVL65:
 1037               	.L65:
 1038               	.LBE33:
 1039               	.LBE32:
 1040               	.LBE31:
 358:main.c        **** 	for(rep = 0;rep < reps;rep++){
 1041               		.loc 1 358 0 discriminator 1
 1042 03c0 0C15      		cp r16,r12
 1043 03c2 1D05      		cpc r17,r13
 1044 03c4 04F0      		brlt .+2
 1045 03c6 00C0      		rjmp .L64
 1046 03c8 C0E0      		ldi r28,lo8(tempo)
 1047 03ca D0E0      		ldi r29,hi8(tempo)
 1048 03cc 80E0      		ldi r24,lo8(melody)
 1049 03ce E82E      		mov r14,r24
 1050 03d0 80E0      		ldi r24,hi8(melody)
 1051 03d2 F82E      		mov r15,r24
 1052               	.L70:
 1053               	.LBB38:
 1054               	.LBB37:
 1055               	.LBB36:
 1056               		.loc 1 364 0
 1057 03d4 6991      		ld r22,Y+
 1058 03d6 7991      		ld r23,Y+
 1059 03d8 C501      		movw r24,r10
 1060 03da 0E94 0000 		call __divmodhi4
 1061               	.LVL66:
 365:main.c        ****  
 366:main.c        **** 	      		buzz(melody[thisNote], noteDuration);
 1062               		.loc 1 366 0
 1063 03de 2B01      		movw r4,r22
 1064 03e0 6624      		clr r6
 1065 03e2 57FC      		sbrc r5,7
 1066 03e4 6094      		com r6
 1067 03e6 762C      		mov r7,r6
 1068 03e8 F701      		movw r30,r14
 1069 03ea 6191      		ld r22,Z+
 1070 03ec 7191      		ld r23,Z+
 1071               	.LVL67:
 1072 03ee 7F01      		movw r14,r30
 1073 03f0 8827      		clr r24
 1074 03f2 77FD      		sbrc r23,7
 1075 03f4 8095      		com r24
 1076 03f6 982F      		mov r25,r24
 1077 03f8 A301      		movw r20,r6
 1078 03fa 9201      		movw r18,r4
 1079 03fc 0E94 0000 		call buzz
 1080               	.LVL68:
 367:main.c        **** 	 
 368:main.c        **** 	      		// to distinguish the notes, set a minimum time between them.
 369:main.c        **** 	      		// the note's duration + 30% seems to work well:
 370:main.c        **** 	      		int pauseBetweenNotes = noteDuration * 1.30;
 1081               		.loc 1 370 0
 1082 0400 C301      		movw r24,r6
 1083 0402 B201      		movw r22,r4
 1084 0404 0E94 0000 		call __floatsisf
 1085               	.LVL69:
 1086 0408 26E6      		ldi r18,lo8(102)
 1087 040a 36E6      		ldi r19,lo8(102)
 1088 040c 46EA      		ldi r20,lo8(-90)
 1089 040e 5FE3      		ldi r21,lo8(63)
 1090 0410 0E94 0000 		call __mulsf3
 1091               	.LVL70:
 1092 0414 0E94 0000 		call __fixsfsi
 1093               	.LVL71:
 1094               	.L66:
 371:main.c        **** 	      		while(pauseBetweenNotes-- != 0)
 1095               		.loc 1 371 0 discriminator 1
 1096 0418 6115      		cp r22,__zero_reg__
 1097 041a 7105      		cpc r23,__zero_reg__
 1098 041c 01F0      		breq .L71
 1099               	.LVL72:
 1100               	.LBB34:
 1101               	.LBB35:
 1102               		.loc 2 245 0
 1103 041e 8FEA      		ldi r24,lo8(1199)
 1104 0420 94E0      		ldi r25,hi8(1199)
 1105 0422 0197      		1: sbiw r24,1
 1106 0424 01F4      		brne 1b
 1107 0426 00C0      		rjmp .
 1108 0428 0000      		nop
 1109 042a 6150      		subi r22,1
 1110 042c 7109      		sbc r23,__zero_reg__
 1111               	.LVL73:
 1112 042e 00C0      		rjmp .L66
 1113               	.LVL74:
 1114               	.L71:
 1115               	.LBE35:
 1116               	.LBE34:
 372:main.c        **** 				_delay_us(300);
 373:main.c        **** 			
 374:main.c        **** 	 
 375:main.c        **** 	     	 	// stop the tone playing:
 376:main.c        **** 	      		buzz(0, noteDuration);
 1117               		.loc 1 376 0
 1118 0430 A301      		movw r20,r6
 1119 0432 9201      		movw r18,r4
 1120 0434 60E0      		ldi r22,0
 1121 0436 70E0      		ldi r23,0
 1122 0438 CB01      		movw r24,r22
 1123               	.LVL75:
 1124 043a 0E94 0000 		call buzz
 1125               	.LVL76:
 1126               	.LBE36:
 360:main.c        ****     		for (int thisNote = 0; thisNote < size; thisNote++) {
 1127               		.loc 1 360 0
 1128 043e 90E0      		ldi r25,hi8(tempo+156)
 1129 0440 C030      		cpi r28,lo8(tempo+156)
 1130 0442 D907      		cpc r29,r25
 1131 0444 01F4      		brne .L70
 1132               	.LBE37:
 1133               	.LBE38:
 358:main.c        **** 	for(rep = 0;rep < reps;rep++){
 1134               		.loc 1 358 0
 1135 0446 0F5F      		subi r16,-1
 1136 0448 1F4F      		sbci r17,-1
 1137               	.LVL77:
 1138 044a 00C0      		rjmp .L65
 1139               	.LVL78:
 1140               	.L64:
 1141               	/* epilogue start */
 377:main.c        **** 	    	}
 378:main.c        **** 	}		
 379:main.c        **** }
 1142               		.loc 1 379 0
 1143 044c DF91      		pop r29
 1144 044e CF91      		pop r28
 1145 0450 1F91      		pop r17
 1146 0452 0F91      		pop r16
 1147               	.LVL79:
 1148 0454 FF90      		pop r15
 1149 0456 EF90      		pop r14
 1150 0458 DF90      		pop r13
 1151 045a CF90      		pop r12
 1152               	.LVL80:
 1153 045c BF90      		pop r11
 1154 045e AF90      		pop r10
 1155 0460 7F90      		pop r7
 1156 0462 6F90      		pop r6
 1157 0464 5F90      		pop r5
 1158 0466 4F90      		pop r4
 1159 0468 0895      		ret
 1160               		.cfi_endproc
 1161               	.LFE20:
 1163               		.section	.rodata.str1.1,"aMS",@progbits,1
 1164               	.LC0:
 1165 0000 5261 7720 		.string	"Raw Reading: %d\t"
 1165      5265 6164 
 1165      696E 673A 
 1165      2025 6409 
 1165      00
 1166               	.LC1:
 1167 0011 4D61 7070 		.string	"Mapped Reading: %d\n"
 1167      6564 2052 
 1167      6561 6469 
 1167      6E67 3A20 
 1167      2564 0A00 
 1168               	.LC2:
 1169 0025 5556 204C 		.string	"UV Lights on for: %d more secs...\n"
 1169      6967 6874 
 1169      7320 6F6E 
 1169      2066 6F72 
 1169      3A20 2564 
 1170               		.section	.text.startup,"ax",@progbits
 1171               	.global	main
 1173               	main:
 1174               	.LFB21:
 380:main.c        **** int main (void){
 1175               		.loc 1 380 0
 1176               		.cfi_startproc
 1177 0000 CF93      		push r28
 1178               	.LCFI57:
 1179               		.cfi_def_cfa_offset 3
 1180               		.cfi_offset 28, -2
 1181 0002 DF93      		push r29
 1182               	.LCFI58:
 1183               		.cfi_def_cfa_offset 4
 1184               		.cfi_offset 29, -3
 1185 0004 00D0      		rcall .
 1186 0006 1F92      		push __zero_reg__
 1187               	.LCFI59:
 1188               		.cfi_def_cfa_offset 7
 1189 0008 CDB7      		in r28,__SP_L__
 1190 000a DEB7      		in r29,__SP_H__
 1191               	.LCFI60:
 1192               		.cfi_def_cfa_register 28
 1193               	/* prologue: function */
 1194               	/* frame size = 3 */
 1195               	/* stack size = 5 */
 1196               	.L__stack_usage = 5
 381:main.c        **** 	//Start UART
 382:main.c        **** 	init_UART();
 1197               		.loc 1 382 0
 1198 000c 0E94 0000 		call init_UART
 1199               	.LVL81:
 383:main.c        **** 	stdout = &uart_tx;
 1200               		.loc 1 383 0
 1201 0010 80E0      		ldi r24,lo8(uart_tx)
 1202 0012 90E0      		ldi r25,hi8(uart_tx)
 1203 0014 9093 0000 		sts __iob+2+1,r25
 1204 0018 8093 0000 		sts __iob+2,r24
 384:main.c        **** 	stdin = &uart_rx;
 1205               		.loc 1 384 0
 1206 001c 80E0      		ldi r24,lo8(uart_rx)
 1207 001e 90E0      		ldi r25,hi8(uart_rx)
 1208 0020 9093 0000 		sts __iob+1,r25
 1209 0024 8093 0000 		sts __iob,r24
 385:main.c        **** 	
 386:main.c        **** 	//Start ADC
 387:main.c        **** 	init_ADC();
 1210               		.loc 1 387 0
 1211 0028 0E94 0000 		call init_ADC
 1212               	.LVL82:
 388:main.c        **** 
 389:main.c        **** 	//Set pins for display as output
 390:main.c        **** 	//Digit 1
 391:main.c        **** 	DDRD |= (1 << PD5); //A
 1213               		.loc 1 391 0
 1214 002c 559A      		sbi 0xa,5
 392:main.c        **** 	DDRD |= (1 << PD6); //B
 1215               		.loc 1 392 0
 1216 002e 569A      		sbi 0xa,6
 393:main.c        **** 	DDRD |= (1 << PD7); //C
 1217               		.loc 1 393 0
 1218 0030 579A      		sbi 0xa,7
 394:main.c        **** 	DDRB |= (1 << PB0); //D
 1219               		.loc 1 394 0
 1220 0032 209A      		sbi 0x4,0
 395:main.c        **** 	
 396:main.c        **** 	//Digit 2
 397:main.c        **** 	DDRC |= (1 << PC1); //A
 1221               		.loc 1 397 0
 1222 0034 399A      		sbi 0x7,1
 398:main.c        **** 	DDRC |= (1 << PC2); //B
 1223               		.loc 1 398 0
 1224 0036 3A9A      		sbi 0x7,2
 399:main.c        **** 	DDRC |= (1 << PC3); //C
 1225               		.loc 1 399 0
 1226 0038 3B9A      		sbi 0x7,3
 400:main.c        **** 	DDRC |= (1 << PC4); //D
 1227               		.loc 1 400 0
 1228 003a 3C9A      		sbi 0x7,4
 401:main.c        **** 
 402:main.c        **** 	//Lights Pin Output
 403:main.c        **** 	DDRC |= (1 << PC5); 
 1229               		.loc 1 403 0
 1230 003c 3D9A      		sbi 0x7,5
 404:main.c        ****  
 405:main.c        **** 	//Start/Stop Button
 406:main.c        **** 	DDRB &= ~(1 << PB1); //Start button input	
 1231               		.loc 1 406 0
 1232 003e 2198      		cbi 0x4,1
 407:main.c        **** 	DDRB &= ~(1 << PB2); //Stop button input
 1233               		.loc 1 407 0
 1234 0040 2298      		cbi 0x4,2
 408:main.c        **** 
 409:main.c        **** 	//Buzzer Pin
 410:main.c        **** 	DDRD |= (1 << PD2); //Output
 1235               		.loc 1 410 0
 1236 0042 529A      		sbi 0xa,2
 1237               	.LVL83:
 411:main.c        **** 
 412:main.c        ****    	int first_digit = 9;
 413:main.c        **** 	int second_digit = 10;    
 414:main.c        ****     	static long reading;
 415:main.c        **** 	static bool btnStop = false;
 416:main.c        **** 	//Blink display to let me know everything is good!
 417:main.c        **** 	displayBlink(5);
 1238               		.loc 1 417 0
 1239 0044 85E0      		ldi r24,lo8(5)
 1240 0046 0E94 0000 		call displayBlink
 1241               	.LVL84:
 1242               	.LBB39:
 1243               	.LBB40:
 1244               	.LBB41:
 172:main.c        **** 	return b1 + (s-a1)*(b2-b1)/(a2-a1);
 1245               		.loc 1 172 0
 1246 004a CC24      		clr r12
 1247 004c CA94      		dec r12
 1248 004e 23E0      		ldi r18,lo8(3)
 1249 0050 D22E      		mov r13,r18
 1250 0052 E12C      		mov r14,__zero_reg__
 1251 0054 F12C      		mov r15,__zero_reg__
 1252               	.LBE41:
 1253               	.LBE40:
 418:main.c        **** 	while(1) {
 419:main.c        **** 		printf("Raw Reading: %d\t",read_ADC(0,&reading));
 420:main.c        **** 		long mapped_reading = mapRange(0,1023,0,99,reading);
 421:main.c        **** 		printf("Mapped Reading: %d\n",mapped_reading);
 1254               		.loc 1 421 0
 1255 0056 30E0      		ldi r19,lo8(.LC1)
 1256 0058 232E      		mov r2,r19
 1257 005a 30E0      		ldi r19,hi8(.LC1)
 1258 005c 332E      		mov r3,r19
 1259               	.LBB43:
 1260               	.LBB44:
 422:main.c        **** 		display_Selection(mapped_reading);
 423:main.c        **** 		if(PINB & (1 << PB1) && mapped_reading > 0 ){ //If the Start button gets pressed then
 424:main.c        **** 			displayBlink(2);
 425:main.c        **** 			int count = 0;
 426:main.c        **** 			_delay_ms(1000);
 427:main.c        **** 			PORTC |= (1 << PC5);
 428:main.c        **** 			for(count = mapped_reading;count >= 0;count--){
 429:main.c        **** 				//Count Backwards from that number	
 430:main.c        **** 				//Check for stop button quit if set
 431:main.c        **** 				if(PINB & (1 << PB2)){
 432:main.c        **** 					btnStop = true;
 433:main.c        **** 					break;
 434:main.c        **** 				}
 435:main.c        **** 
 436:main.c        **** 				uint8_t fdigitm = count / 10;
 1261               		.loc 1 436 0
 1262 005e 4AE0      		ldi r20,lo8(10)
 1263 0060 A42E      		mov r10,r20
 1264 0062 B12C      		mov r11,__zero_reg__
 437:main.c        **** 				uint8_t sdigitm = count % 10;
 438:main.c        **** 				firstDisplay(fdigitm);
 439:main.c        **** 				secondDisplay(sdigitm);
 440:main.c        **** 				printf("UV Lights on for: %d more secs...\n",count);
 1265               		.loc 1 440 0
 1266 0064 00E0      		ldi r16,lo8(.LC2)
 1267 0066 10E0      		ldi r17,hi8(.LC2)
 1268               	.L73:
 1269               	.LBE44:
 1270               	.LBE43:
 419:main.c        **** 		printf("Raw Reading: %d\t",read_ADC(0,&reading));
 1271               		.loc 1 419 0
 1272 0068 60E0      		ldi r22,lo8(reading.2002)
 1273 006a 70E0      		ldi r23,hi8(reading.2002)
 1274 006c 80E0      		ldi r24,0
 1275 006e 0E94 0000 		call read_ADC
 1276               	.LVL85:
 1277 0072 9F93      		push r25
 1278 0074 8F93      		push r24
 1279 0076 A0E0      		ldi r26,lo8(.LC0)
 1280 0078 B0E0      		ldi r27,hi8(.LC0)
 1281 007a BF93      		push r27
 1282 007c AF93      		push r26
 1283 007e 0E94 0000 		call printf
 1284               	.LVL86:
 1285               	.LBB50:
 1286               	.LBB42:
 172:main.c        **** 	return b1 + (s-a1)*(b2-b1)/(a2-a1);
 1287               		.loc 1 172 0
 1288 0082 2091 0000 		lds r18,reading.2002
 1289 0086 3091 0000 		lds r19,reading.2002+1
 1290 008a 4091 0000 		lds r20,reading.2002+2
 1291 008e 5091 0000 		lds r21,reading.2002+3
 1292 0092 A3E6      		ldi r26,lo8(99)
 1293 0094 B0E0      		ldi r27,0
 1294 0096 0E94 0000 		call __muluhisi3
 1295 009a A701      		movw r20,r14
 1296 009c 9601      		movw r18,r12
 1297 009e 0E94 0000 		call __divmodsi4
 1298 00a2 2901      		movw r4,r18
 1299 00a4 3A01      		movw r6,r20
 1300               	.LBE42:
 1301               	.LBE50:
 421:main.c        **** 		printf("Mapped Reading: %d\n",mapped_reading);
 1302               		.loc 1 421 0
 1303 00a6 7F92      		push r7
 1304 00a8 6F92      		push r6
 1305 00aa 5F92      		push r5
 1306 00ac 2F93      		push r18
 1307 00ae 3F92      		push r3
 1308 00b0 2F92      		push r2
 1309 00b2 0E94 0000 		call printf
 1310               	.LVL87:
 422:main.c        **** 		display_Selection(mapped_reading);
 1311               		.loc 1 422 0
 1312 00b6 842D      		mov r24,r4
 1313 00b8 0E94 0000 		call display_Selection
 1314               	.LVL88:
 423:main.c        **** 		if(PINB & (1 << PB1) && mapped_reading > 0 ){ //If the Start button gets pressed then
 1315               		.loc 1 423 0
 1316 00bc 0FB6      		in __tmp_reg__,__SREG__
 1317 00be F894      		cli
 1318 00c0 DEBF      		out __SP_H__,r29
 1319 00c2 0FBE      		out __SREG__,__tmp_reg__
 1320 00c4 CDBF      		out __SP_L__,r28
 1321 00c6 199B      		sbis 0x3,1
 1322 00c8 00C0      		rjmp .L73
 423:main.c        **** 		if(PINB & (1 << PB1) && mapped_reading > 0 ){ //If the Start button gets pressed then
 1323               		.loc 1 423 0 is_stmt 0 discriminator 1
 1324 00ca 1414      		cp __zero_reg__,r4
 1325 00cc 1504      		cpc __zero_reg__,r5
 1326 00ce 1604      		cpc __zero_reg__,r6
 1327 00d0 1704      		cpc __zero_reg__,r7
 1328 00d2 04F4      		brge .L73
 1329               	.LBB51:
 424:main.c        **** 			displayBlink(2);
 1330               		.loc 1 424 0 is_stmt 1
 1331 00d4 82E0      		ldi r24,lo8(2)
 1332 00d6 0E94 0000 		call displayBlink
 1333               	.LVL89:
 1334               	.LBB47:
 1335               	.LBB48:
 163:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1336               		.loc 2 163 0
 1337 00da 9FEF      		ldi r25,lo8(3199999)
 1338 00dc A3ED      		ldi r26,hi8(3199999)
 1339 00de B0E3      		ldi r27,hlo8(3199999)
 1340 00e0 9150      		1: subi r25,1
 1341 00e2 A040      		sbci r26,0
 1342 00e4 B040      		sbci r27,0
 1343 00e6 01F4      		brne 1b
 1344 00e8 00C0      		rjmp .
 1345 00ea 0000      		nop
 1346               	.LBE48:
 1347               	.LBE47:
 427:main.c        **** 			PORTC |= (1 << PC5);
 1348               		.loc 1 427 0
 1349 00ec 459A      		sbi 0x8,5
 1350               	.LVL90:
 428:main.c        **** 			for(count = mapped_reading;count >= 0;count--){
 1351               		.loc 1 428 0
 1352 00ee 812C      		mov r8,__zero_reg__
 1353 00f0 912C      		mov r9,__zero_reg__
 1354               	.L75:
 1355 00f2 9201      		movw r18,r4
 1356 00f4 2819      		sub r18,r8
 1357 00f6 3909      		sbc r19,r9
 1358               	.LVL91:
 428:main.c        **** 			for(count = mapped_reading;count >= 0;count--){
 1359               		.loc 1 428 0 is_stmt 0 discriminator 1
 1360 00f8 37FD      		sbrc r19,7
 1361 00fa 00C0      		rjmp .L77
 1362 00fc EFEF      		ldi r30,-1
 1363 00fe 8E1A      		sub r8,r30
 1364 0100 9E0A      		sbc r9,r30
 1365               	.LBB49:
 431:main.c        **** 				if(PINB & (1 << PB2)){
 1366               		.loc 1 431 0 is_stmt 1
 1367 0102 1A9B      		sbis 0x3,2
 1368 0104 00C0      		rjmp .L76
 432:main.c        **** 					btnStop = true;
 1369               		.loc 1 432 0
 1370 0106 F1E0      		ldi r31,lo8(1)
 1371 0108 F093 0000 		sts btnStop.2003,r31
 433:main.c        **** 					break;
 1372               		.loc 1 433 0
 1373 010c 00C0      		rjmp .L77
 1374               	.L76:
 1375               	.LVL92:
 436:main.c        **** 				uint8_t fdigitm = count / 10;
 1376               		.loc 1 436 0
 1377 010e C901      		movw r24,r18
 1378 0110 B501      		movw r22,r10
 1379 0112 0E94 0000 		call __divmodhi4
 1380 0116 982F      		mov r25,r24
 438:main.c        **** 				firstDisplay(fdigitm);
 1381               		.loc 1 438 0
 1382 0118 862F      		mov r24,r22
 1383 011a 2A83      		std Y+2,r18
 1384 011c 3B83      		std Y+3,r19
 1385 011e 9983      		std Y+1,r25
 1386 0120 0E94 0000 		call firstDisplay
 1387               	.LVL93:
 439:main.c        **** 				secondDisplay(sdigitm);
 1388               		.loc 1 439 0
 1389 0124 9981      		ldd r25,Y+1
 1390 0126 892F      		mov r24,r25
 1391 0128 0E94 0000 		call secondDisplay
 1392               	.LVL94:
 1393               		.loc 1 440 0
 1394 012c 2A81      		ldd r18,Y+2
 1395 012e 3B81      		ldd r19,Y+3
 1396 0130 3F93      		push r19
 1397 0132 2F93      		push r18
 1398 0134 1F93      		push r17
 1399 0136 0F93      		push r16
 1400 0138 0E94 0000 		call printf
 1401               	.LVL95:
 1402               	.LBB45:
 1403               	.LBB46:
 163:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1404               		.loc 2 163 0
 1405 013c 2FEF      		ldi r18,lo8(3199999)
 1406 013e 83ED      		ldi r24,hi8(3199999)
 1407 0140 90E3      		ldi r25,hlo8(3199999)
 1408 0142 2150      		1: subi r18,1
 1409 0144 8040      		sbci r24,0
 1410 0146 9040      		sbci r25,0
 1411 0148 01F4      		brne 1b
 1412 014a 00C0      		rjmp .
 1413 014c 0000      		nop
 1414               	.LVL96:
 1415 014e 0F90      		pop __tmp_reg__
 1416 0150 0F90      		pop __tmp_reg__
 1417 0152 0F90      		pop __tmp_reg__
 1418 0154 0F90      		pop __tmp_reg__
 1419 0156 00C0      		rjmp .L75
 1420               	.LVL97:
 1421               	.L77:
 1422               	.LBE46:
 1423               	.LBE45:
 1424               	.LBE49:
 441:main.c        **** 				_delay_ms(1000);
 442:main.c        **** 			}	
 443:main.c        **** 			PORTC &= ~(1 << PC5);
 1425               		.loc 1 443 0
 1426 0158 4598      		cbi 0x8,5
 444:main.c        **** 			//displayBlink(5);
 445:main.c        **** 			if(btnStop != true){
 1427               		.loc 1 445 0
 1428 015a 8091 0000 		lds r24,btnStop.2003
 1429 015e 8111      		cpse r24,__zero_reg__
 1430 0160 00C0      		rjmp .L79
 446:main.c        **** 				alarmSound(2);
 1431               		.loc 1 446 0
 1432 0162 82E0      		ldi r24,lo8(2)
 1433 0164 0E94 0000 		call alarmSound
 1434               	.LVL98:
 1435 0168 00C0      		rjmp .L80
 1436               	.LVL99:
 1437               	.L79:
 447:main.c        **** 			}
 448:main.c        **** 			else{
 449:main.c        **** 				buzzerSound(13);
 1438               		.loc 1 449 0
 1439 016a 8DE0      		ldi r24,lo8(13)
 1440 016c 0E94 0000 		call buzzerSound
 1441               	.LVL100:
 450:main.c        **** 				btnStop = false; //reset the flag	
 1442               		.loc 1 450 0
 1443 0170 1092 0000 		sts btnStop.2003,__zero_reg__
 1444               	.L80:
 451:main.c        **** 			}
 452:main.c        **** 			displayBlink(2);
 1445               		.loc 1 452 0
 1446 0174 82E0      		ldi r24,lo8(2)
 1447 0176 0E94 0000 		call displayBlink
 1448               	.LVL101:
 1449 017a 00C0      		rjmp .L73
 1450               	.LBE51:
 1451               	.LBE39:
 1452               		.cfi_endproc
 1453               	.LFE21:
 1455               		.local	btnStop.2003
 1456               		.comm	btnStop.2003,1,1
 1457               		.local	reading.2002
 1458               		.comm	reading.2002,4,1
 1459               	.global	tempo
 1460               		.data
 1463               	tempo:
 1464 0000 0C00      		.word	12
 1465 0002 0C00      		.word	12
 1466 0004 0C00      		.word	12
 1467 0006 0C00      		.word	12
 1468 0008 0C00      		.word	12
 1469 000a 0C00      		.word	12
 1470 000c 0C00      		.word	12
 1471 000e 0C00      		.word	12
 1472 0010 0C00      		.word	12
 1473 0012 0C00      		.word	12
 1474 0014 0C00      		.word	12
 1475 0016 0C00      		.word	12
 1476 0018 0C00      		.word	12
 1477 001a 0C00      		.word	12
 1478 001c 0C00      		.word	12
 1479 001e 0C00      		.word	12
 1480 0020 0C00      		.word	12
 1481 0022 0C00      		.word	12
 1482 0024 0C00      		.word	12
 1483 0026 0C00      		.word	12
 1484 0028 0C00      		.word	12
 1485 002a 0C00      		.word	12
 1486 002c 0C00      		.word	12
 1487 002e 0C00      		.word	12
 1488 0030 0C00      		.word	12
 1489 0032 0C00      		.word	12
 1490 0034 0C00      		.word	12
 1491 0036 0C00      		.word	12
 1492 0038 0C00      		.word	12
 1493 003a 0C00      		.word	12
 1494 003c 0C00      		.word	12
 1495 003e 0C00      		.word	12
 1496 0040 0900      		.word	9
 1497 0042 0900      		.word	9
 1498 0044 0900      		.word	9
 1499 0046 0C00      		.word	12
 1500 0048 0C00      		.word	12
 1501 004a 0C00      		.word	12
 1502 004c 0C00      		.word	12
 1503 004e 0C00      		.word	12
 1504 0050 0C00      		.word	12
 1505 0052 0C00      		.word	12
 1506 0054 0C00      		.word	12
 1507 0056 0C00      		.word	12
 1508 0058 0C00      		.word	12
 1509 005a 0C00      		.word	12
 1510 005c 0C00      		.word	12
 1511 005e 0C00      		.word	12
 1512 0060 0C00      		.word	12
 1513 0062 0C00      		.word	12
 1514 0064 0C00      		.word	12
 1515 0066 0C00      		.word	12
 1516 0068 0C00      		.word	12
 1517 006a 0C00      		.word	12
 1518 006c 0C00      		.word	12
 1519 006e 0C00      		.word	12
 1520 0070 0C00      		.word	12
 1521 0072 0C00      		.word	12
 1522 0074 0C00      		.word	12
 1523 0076 0C00      		.word	12
 1524 0078 0C00      		.word	12
 1525 007a 0C00      		.word	12
 1526 007c 0C00      		.word	12
 1527 007e 0900      		.word	9
 1528 0080 0900      		.word	9
 1529 0082 0900      		.word	9
 1530 0084 0C00      		.word	12
 1531 0086 0C00      		.word	12
 1532 0088 0C00      		.word	12
 1533 008a 0C00      		.word	12
 1534 008c 0C00      		.word	12
 1535 008e 0C00      		.word	12
 1536 0090 0C00      		.word	12
 1537 0092 0C00      		.word	12
 1538 0094 0C00      		.word	12
 1539 0096 0C00      		.word	12
 1540 0098 0C00      		.word	12
 1541 009a 0C00      		.word	12
 1542               	.global	melody
 1545               	melody:
 1546 009c 4D0A      		.word	2637
 1547 009e 4D0A      		.word	2637
 1548 00a0 0000      		.word	0
 1549 00a2 4D0A      		.word	2637
 1550 00a4 0000      		.word	0
 1551 00a6 2D08      		.word	2093
 1552 00a8 4D0A      		.word	2637
 1553 00aa 0000      		.word	0
 1554 00ac 400C      		.word	3136
 1555 00ae 0000      		.word	0
 1556 00b0 0000      		.word	0
 1557 00b2 0000      		.word	0
 1558 00b4 2006      		.word	1568
 1559 00b6 0000      		.word	0
 1560 00b8 0000      		.word	0
 1561 00ba 0000      		.word	0
 1562 00bc 2D08      		.word	2093
 1563 00be 0000      		.word	0
 1564 00c0 0000      		.word	0
 1565 00c2 2006      		.word	1568
 1566 00c4 0000      		.word	0
 1567 00c6 0000      		.word	0
 1568 00c8 2705      		.word	1319
 1569 00ca 0000      		.word	0
 1570 00cc 0000      		.word	0
 1571 00ce E006      		.word	1760
 1572 00d0 0000      		.word	0
 1573 00d2 B807      		.word	1976
 1574 00d4 0000      		.word	0
 1575 00d6 4907      		.word	1865
 1576 00d8 E006      		.word	1760
 1577 00da 0000      		.word	0
 1578 00dc 2006      		.word	1568
 1579 00de 4D0A      		.word	2637
 1580 00e0 400C      		.word	3136
 1581 00e2 C00D      		.word	3520
 1582 00e4 0000      		.word	0
 1583 00e6 EA0A      		.word	2794
 1584 00e8 400C      		.word	3136
 1585 00ea 0000      		.word	0
 1586 00ec 4D0A      		.word	2637
 1587 00ee 0000      		.word	0
 1588 00f0 2D08      		.word	2093
 1589 00f2 2D09      		.word	2349
 1590 00f4 B807      		.word	1976
 1591 00f6 0000      		.word	0
 1592 00f8 0000      		.word	0
 1593 00fa 2D08      		.word	2093
 1594 00fc 0000      		.word	0
 1595 00fe 0000      		.word	0
 1596 0100 2006      		.word	1568
 1597 0102 0000      		.word	0
 1598 0104 0000      		.word	0
 1599 0106 2705      		.word	1319
 1600 0108 0000      		.word	0
 1601 010a 0000      		.word	0
 1602 010c E006      		.word	1760
 1603 010e 0000      		.word	0
 1604 0110 B807      		.word	1976
 1605 0112 0000      		.word	0
 1606 0114 4907      		.word	1865
 1607 0116 E006      		.word	1760
 1608 0118 0000      		.word	0
 1609 011a 2006      		.word	1568
 1610 011c 4D0A      		.word	2637
 1611 011e 400C      		.word	3136
 1612 0120 C00D      		.word	3520
 1613 0122 0000      		.word	0
 1614 0124 EA0A      		.word	2794
 1615 0126 400C      		.word	3136
 1616 0128 0000      		.word	0
 1617 012a 4D0A      		.word	2637
 1618 012c 0000      		.word	0
 1619 012e 2D08      		.word	2093
 1620 0130 2D09      		.word	2349
 1621 0132 B807      		.word	1976
 1622 0134 0000      		.word	0
 1623 0136 0000      		.word	0
 1624               	.global	uart_rx
 1627               	uart_rx:
 1628 0138 0000 00   		.zero	3
 1629 013b 01        		.byte	1
 1630 013c 0000 0000 		.zero	4
 1631 0140 0000      		.word	0
 1632 0142 0000      		.word	gs(uart_getchar)
 1633 0144 0000      		.word	0
 1634               	.global	uart_tx
 1637               	uart_tx:
 1638 0146 0000 00   		.zero	3
 1639 0149 02        		.byte	2
 1640 014a 0000 0000 		.zero	4
 1641 014e 0000      		.word	gs(uart_putchar)
 1642 0150 0000      		.word	0
 1643 0152 0000      		.word	0
 1644               		.text
 1645               	.Letext0:
 1646               		.file 3 "/usr/local/CrossPack-AVR-20131216/avr/include/stdint.h"
 1647               		.file 4 "/usr/local/CrossPack-AVR-20131216/avr/include/stdio.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccn2w6YG.s:2      *ABS*:0000003e __SP_H__
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccn2w6YG.s:3      *ABS*:0000003d __SP_L__
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccn2w6YG.s:4      *ABS*:0000003f __SREG__
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccn2w6YG.s:5      *ABS*:00000000 __tmp_reg__
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccn2w6YG.s:6      *ABS*:00000001 __zero_reg__
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccn2w6YG.s:12     .text:00000000 uart_putchar
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccn2w6YG.s:54     .text:00000022 uart_getchar
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccn2w6YG.s:78     .text:00000032 init_UART
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccn2w6YG.s:103    .text:0000004a init_ADC
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccn2w6YG.s:123    .text:00000058 read_ADC
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccn2w6YG.s:174    .text:000000a0 firstDisplay
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccn2w6YG.s:274    .text:00000106 secondDisplay
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccn2w6YG.s:374    .text:0000016c display_Selection
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccn2w6YG.s:448    .text:000001a4 mapRange
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccn2w6YG.s:592    .text:0000023e displayBlink
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccn2w6YG.s:694    .text:0000029e delayMicro
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccn2w6YG.s:730    .text:000002b0 buzz
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccn2w6YG.s:887    .text:0000035c buzzerSound
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccn2w6YG.s:957    .text:00000394 alarmSound
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccn2w6YG.s:1463   .data:00000000 tempo
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccn2w6YG.s:1545   .data:0000009c melody
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccn2w6YG.s:1173   .text.startup:00000000 main
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccn2w6YG.s:1637   .data:00000146 uart_tx
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccn2w6YG.s:1627   .data:00000138 uart_rx
/var/folders/j8/03g8qp616k1dqr37k98mkv2c0000gn/T//ccn2w6YG.s:1456   .bss:00000001 reading.2002
                             .bss:00000000 btnStop.2003

UNDEFINED SYMBOLS
__udivmodqi4
__mulsi3
__divmodsi4
__floatsisf
__mulsf3
__fixsfsi
__divmodhi4
__iob
printf
__muluhisi3
__do_copy_data
__do_clear_bss
